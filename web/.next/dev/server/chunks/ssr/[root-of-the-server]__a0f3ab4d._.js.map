{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/lib/react-query.ts"],"sourcesContent":["/**\r\n * React Query Configuration\r\n *\r\n * This file exports a factory function for creating QueryClient instances.\r\n * DO NOT add 'use client' directive - this is a utility module imported by both\r\n * Server and Client Components.\r\n *\r\n * CRITICAL NEXT.JS 16 + REACT 19 PATTERN:\r\n * - The QueryClient must be created using useState in the Providers component\r\n * - Module-level singletons break during SSR/hydration with React 19's automatic batching\r\n * - See: https://tanstack.com/query/latest/docs/framework/react/guides/nextjs\r\n */\r\n\r\nimport { QueryClient } from '@tanstack/react-query';\r\n\r\n/**\r\n * Creates a new QueryClient instance with recommended defaults for Next.js 16 + React 19\r\n *\r\n * Configuration:\r\n * - staleTime: 60s (avoid immediate refetch on client after SSR)\r\n * - refetchOnWindowFocus: true (keep data fresh when user returns)\r\n * - retry: 1 (single retry on failure)\r\n *\r\n * @returns A new QueryClient instance\r\n */\r\nexport function makeQueryClient() {\r\n  return new QueryClient({\r\n    defaultOptions: {\r\n      queries: {\r\n        // With SSR, we usually want to set some default staleTime\r\n        // above 0 to avoid refetching immediately on the client\r\n        staleTime: 60 * 1000,\r\n\r\n        // Refetch on window focus for data freshness\r\n        refetchOnWindowFocus: true,\r\n\r\n        // Only retry once on error (prevents infinite loops)\r\n        retry: 1,\r\n      },\r\n    },\r\n  });\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;CAWC;;;;AAED;;AAYO,SAAS;IACd,OAAO,IAAI,4LAAW,CAAC;QACrB,gBAAgB;YACd,SAAS;gBACP,0DAA0D;gBAC1D,wDAAwD;gBACxD,WAAW,KAAK;gBAEhB,6CAA6C;gBAC7C,sBAAsB;gBAEtB,qDAAqD;gBACrD,OAAO;YACT;QACF;IACF;AACF","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/api/client/api-errors.ts"],"sourcesContent":["/**\r\n * Base API Error class\r\n */\r\nexport class ApiError extends Error {\r\n  public readonly statusCode?: number;\r\n  public readonly validationErrors?: Record<string, string[]>;\r\n  public readonly response?: any; // Preserve original axios response for debugging\r\n\r\n  constructor(message: string, statusCode?: number, validationErrors?: Record<string, string[]>, response?: any) {\r\n    super(message);\r\n    this.name = 'ApiError';\r\n    this.statusCode = statusCode;\r\n    this.validationErrors = validationErrors;\r\n    this.response = response;\r\n    Object.setPrototypeOf(this, ApiError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Network Error (no response from server)\r\n */\r\nexport class NetworkError extends ApiError {\r\n  constructor(message: string = 'Network error occurred') {\r\n    super(message);\r\n    this.name = 'NetworkError';\r\n    Object.setPrototypeOf(this, NetworkError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Validation Error (400)\r\n */\r\nexport class ValidationError extends ApiError {\r\n  constructor(message: string = 'Validation failed', validationErrors?: Record<string, string[]>, response?: any) {\r\n    super(message, 400, validationErrors, response);\r\n    this.name = 'ValidationError';\r\n    Object.setPrototypeOf(this, ValidationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Unauthorized Error (401)\r\n */\r\nexport class UnauthorizedError extends ApiError {\r\n  constructor(message: string = 'Unauthorized') {\r\n    super(message, 401);\r\n    this.name = 'UnauthorizedError';\r\n    Object.setPrototypeOf(this, UnauthorizedError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Forbidden Error (403)\r\n */\r\nexport class ForbiddenError extends ApiError {\r\n  constructor(message: string = 'Forbidden') {\r\n    super(message, 403);\r\n    this.name = 'ForbiddenError';\r\n    Object.setPrototypeOf(this, ForbiddenError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Not Found Error (404)\r\n */\r\nexport class NotFoundError extends ApiError {\r\n  constructor(message: string = 'Resource not found') {\r\n    super(message, 404);\r\n    this.name = 'NotFoundError';\r\n    Object.setPrototypeOf(this, NotFoundError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Server Error (500+)\r\n */\r\nexport class ServerError extends ApiError {\r\n  constructor(message: string = 'Internal server error', statusCode: number = 500) {\r\n    super(message, statusCode);\r\n    this.name = 'ServerError';\r\n    Object.setPrototypeOf(this, ServerError.prototype);\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;;;;;AACM,MAAM,iBAAiB;IACZ,WAAoB;IACpB,iBAA4C;IAC5C,SAAe;IAE/B,YAAY,OAAe,EAAE,UAAmB,EAAE,gBAA2C,EAAE,QAAc,CAAE;QAC7G,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,QAAQ,GAAG;QAChB,OAAO,cAAc,CAAC,IAAI,EAAE,SAAS,SAAS;IAChD;AACF;AAKO,MAAM,qBAAqB;IAChC,YAAY,UAAkB,wBAAwB,CAAE;QACtD,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,aAAa,SAAS;IACpD;AACF;AAKO,MAAM,wBAAwB;IACnC,YAAY,UAAkB,mBAAmB,EAAE,gBAA2C,EAAE,QAAc,CAAE;QAC9G,KAAK,CAAC,SAAS,KAAK,kBAAkB;QACtC,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB,SAAS;IACvD;AACF;AAKO,MAAM,0BAA0B;IACrC,YAAY,UAAkB,cAAc,CAAE;QAC5C,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,kBAAkB,SAAS;IACzD;AACF;AAKO,MAAM,uBAAuB;IAClC,YAAY,UAAkB,WAAW,CAAE;QACzC,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,eAAe,SAAS;IACtD;AACF;AAKO,MAAM,sBAAsB;IACjC,YAAY,UAAkB,oBAAoB,CAAE;QAClD,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,cAAc,SAAS;IACrD;AACF;AAKO,MAAM,oBAAoB;IAC/B,YAAY,UAAkB,uBAAuB,EAAE,aAAqB,GAAG,CAAE;QAC/E,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,YAAY,SAAS;IACnD;AACF","debugId":null}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/storage/localStorage.ts"],"sourcesContent":["/**\r\n * LocalStorage Utility\r\n * Type-safe wrapper for localStorage with error handling\r\n */\r\n\r\nconst STORAGE_KEYS = {\r\n  ACCESS_TOKEN: 'lankaconnect_access_token',\r\n  REFRESH_TOKEN: 'lankaconnect_refresh_token',\r\n  USER: 'lankaconnect_user',\r\n} as const;\r\n\r\nexport class LocalStorageService {\r\n  /**\r\n   * Check if localStorage is available\r\n   */\r\n  private static isAvailable(): boolean {\r\n    try {\r\n      const test = '__localStorage_test__';\r\n      localStorage.setItem(test, test);\r\n      localStorage.removeItem(test);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get item from localStorage\r\n   */\r\n  static getItem<T>(key: string): T | null {\r\n    if (!this.isAvailable()) {\r\n      console.warn('localStorage is not available');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const item = localStorage.getItem(key);\r\n      if (!item) return null;\r\n      return JSON.parse(item) as T;\r\n    } catch (error) {\r\n      console.error(`Error reading from localStorage (${key}):`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set item in localStorage\r\n   */\r\n  static setItem<T>(key: string, value: T): boolean {\r\n    if (!this.isAvailable()) {\r\n      console.warn('localStorage is not available');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Error writing to localStorage (${key}):`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove item from localStorage\r\n   */\r\n  static removeItem(key: string): void {\r\n    if (!this.isAvailable()) {\r\n      console.warn('localStorage is not available');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      localStorage.removeItem(key);\r\n    } catch (error) {\r\n      console.error(`Error removing from localStorage (${key}):`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all items from localStorage\r\n   */\r\n  static clear(): void {\r\n    if (!this.isAvailable()) {\r\n      console.warn('localStorage is not available');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      localStorage.clear();\r\n    } catch (error) {\r\n      console.error('Error clearing localStorage:', error);\r\n    }\r\n  }\r\n\r\n  // Auth-specific methods\r\n  static getAccessToken(): string | null {\r\n    return this.getItem<string>(STORAGE_KEYS.ACCESS_TOKEN);\r\n  }\r\n\r\n  static setAccessToken(token: string): boolean {\r\n    return this.setItem(STORAGE_KEYS.ACCESS_TOKEN, token);\r\n  }\r\n\r\n  static getRefreshToken(): string | null {\r\n    return this.getItem<string>(STORAGE_KEYS.REFRESH_TOKEN);\r\n  }\r\n\r\n  static setRefreshToken(token: string): boolean {\r\n    return this.setItem(STORAGE_KEYS.REFRESH_TOKEN, token);\r\n  }\r\n\r\n  static getUser<T>(): T | null {\r\n    return this.getItem<T>(STORAGE_KEYS.USER);\r\n  }\r\n\r\n  static setUser<T>(user: T): boolean {\r\n    return this.setItem(STORAGE_KEYS.USER, user);\r\n  }\r\n\r\n  static clearAuth(): void {\r\n    this.removeItem(STORAGE_KEYS.ACCESS_TOKEN);\r\n    this.removeItem(STORAGE_KEYS.REFRESH_TOKEN);\r\n    this.removeItem(STORAGE_KEYS.USER);\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAED,MAAM,eAAe;IACnB,cAAc;IACd,eAAe;IACf,MAAM;AACR;AAEO,MAAM;IACX;;GAEC,GACD,OAAe,cAAuB;QACpC,IAAI;YACF,MAAM,OAAO;YACb,aAAa,OAAO,CAAC,MAAM;YAC3B,aAAa,UAAU,CAAC;YACxB,OAAO;QACT,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA;;GAEC,GACD,OAAO,QAAW,GAAW,EAAY;QACvC,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI;YACvB,QAAQ,IAAI,CAAC;YACb,OAAO;QACT;QAEA,IAAI;YACF,MAAM,OAAO,aAAa,OAAO,CAAC;YAClC,IAAI,CAAC,MAAM,OAAO;YAClB,OAAO,KAAK,KAAK,CAAC;QACpB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,iCAAiC,EAAE,IAAI,EAAE,CAAC,EAAE;YAC3D,OAAO;QACT;IACF;IAEA;;GAEC,GACD,OAAO,QAAW,GAAW,EAAE,KAAQ,EAAW;QAChD,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI;YACvB,QAAQ,IAAI,CAAC;YACb,OAAO;QACT;QAEA,IAAI;YACF,aAAa,OAAO,CAAC,KAAK,KAAK,SAAS,CAAC;YACzC,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,+BAA+B,EAAE,IAAI,EAAE,CAAC,EAAE;YACzD,OAAO;QACT;IACF;IAEA;;GAEC,GACD,OAAO,WAAW,GAAW,EAAQ;QACnC,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI;YACvB,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,IAAI;YACF,aAAa,UAAU,CAAC;QAC1B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,kCAAkC,EAAE,IAAI,EAAE,CAAC,EAAE;QAC9D;IACF;IAEA;;GAEC,GACD,OAAO,QAAc;QACnB,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI;YACvB,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,IAAI;YACF,aAAa,KAAK;QACpB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;QAChD;IACF;IAEA,wBAAwB;IACxB,OAAO,iBAAgC;QACrC,OAAO,IAAI,CAAC,OAAO,CAAS,aAAa,YAAY;IACvD;IAEA,OAAO,eAAe,KAAa,EAAW;QAC5C,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,YAAY,EAAE;IACjD;IAEA,OAAO,kBAAiC;QACtC,OAAO,IAAI,CAAC,OAAO,CAAS,aAAa,aAAa;IACxD;IAEA,OAAO,gBAAgB,KAAa,EAAW;QAC7C,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,aAAa,EAAE;IAClD;IAEA,OAAO,UAAuB;QAC5B,OAAO,IAAI,CAAC,OAAO,CAAI,aAAa,IAAI;IAC1C;IAEA,OAAO,QAAW,IAAO,EAAW;QAClC,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,IAAI,EAAE;IACzC;IAEA,OAAO,YAAkB;QACvB,IAAI,CAAC,UAAU,CAAC,aAAa,YAAY;QACzC,IAAI,CAAC,UAAU,CAAC,aAAa,aAAa;QAC1C,IAAI,CAAC,UAAU,CAAC,aAAa,IAAI;IACnC;AACF","debugId":null}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/presentation/store/useAuthStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { devtools, persist } from 'zustand/middleware';\r\nimport type { UserDto, AuthTokens } from '@/infrastructure/api/types/auth.types';\r\nimport { LocalStorageService } from '@/infrastructure/storage/localStorage';\r\nimport { apiClient } from '@/infrastructure/api/client/api-client';\r\n\r\ninterface AuthState {\r\n  // State\r\n  user: UserDto | null;\r\n  accessToken: string | null;\r\n  refreshToken: string | null;\r\n  isAuthenticated: boolean;\r\n  isLoading: boolean;\r\n\r\n  // Actions\r\n  setAuth: (user: UserDto, tokens: AuthTokens) => void;\r\n  clearAuth: () => void;\r\n  setLoading: (loading: boolean) => void;\r\n  updateUser: (user: Partial<UserDto>) => void;\r\n}\r\n\r\n/**\r\n * Auth Store\r\n * Global state management for authentication using Zustand\r\n */\r\nexport const useAuthStore = create<AuthState>()(\r\n  devtools(\r\n    persist(\r\n      (set, get) => ({\r\n        // Initial state\r\n        user: null,\r\n        accessToken: null,\r\n        refreshToken: null,\r\n        isAuthenticated: false,\r\n        isLoading: false,\r\n\r\n        // Set authentication (after login/register)\r\n        setAuth: (user, tokens) => {\r\n          // Store tokens in localStorage\r\n          LocalStorageService.setAccessToken(tokens.accessToken);\r\n          LocalStorageService.setRefreshToken(tokens.refreshToken);\r\n          LocalStorageService.setUser(user);\r\n\r\n          // Set auth token in API client\r\n          apiClient.setAuthToken(tokens.accessToken);\r\n\r\n          set({\r\n            user,\r\n            accessToken: tokens.accessToken,\r\n            refreshToken: tokens.refreshToken,\r\n            isAuthenticated: true,\r\n            isLoading: false,\r\n          });\r\n        },\r\n\r\n        // Clear authentication (logout)\r\n        clearAuth: () => {\r\n          console.log('üîç [AUTH STORE] clearAuth() called');\r\n          console.trace('üîç [AUTH STORE] Stack trace:');\r\n\r\n          // Clear localStorage\r\n          console.log('üîç [AUTH STORE] Clearing localStorage');\r\n          LocalStorageService.clearAuth();\r\n\r\n          // Clear auth token from API client\r\n          console.log('üîç [AUTH STORE] Clearing API client auth token');\r\n          apiClient.clearAuthToken();\r\n\r\n          console.log('üîç [AUTH STORE] Setting state to unauthenticated');\r\n          set({\r\n            user: null,\r\n            accessToken: null,\r\n            refreshToken: null,\r\n            isAuthenticated: false,\r\n            isLoading: false,\r\n          });\r\n\r\n          console.log('üîç [AUTH STORE] clearAuth() completed');\r\n        },\r\n\r\n        // Set loading state\r\n        setLoading: (loading) => {\r\n          set({ isLoading: loading });\r\n        },\r\n\r\n        // Update user data\r\n        updateUser: (userData) => {\r\n          const currentUser = get().user;\r\n          if (!currentUser) return;\r\n\r\n          const updatedUser = { ...currentUser, ...userData };\r\n          LocalStorageService.setUser(updatedUser);\r\n\r\n          set({ user: updatedUser });\r\n        },\r\n      }),\r\n      {\r\n        name: 'auth-storage',\r\n        partialize: (state) => ({\r\n          user: state.user,\r\n          accessToken: state.accessToken,\r\n          refreshToken: state.refreshToken,\r\n          isAuthenticated: state.isAuthenticated,\r\n        }),\r\n        onRehydrateStorage: () => (state) => {\r\n          // Restore auth token to API client on app load\r\n          if (state?.accessToken) {\r\n            apiClient.setAuthToken(state.accessToken);\r\n          }\r\n        },\r\n      }\r\n    ),\r\n    { name: 'AuthStore' }\r\n  )\r\n);\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AAEA;AACA;;;;;AAqBO,MAAM,eAAe,IAAA,kJAAM,IAChC,IAAA,yJAAQ,EACN,IAAA,wJAAO,EACL,CAAC,KAAK,MAAQ,CAAC;QACb,gBAAgB;QAChB,MAAM;QACN,aAAa;QACb,cAAc;QACd,iBAAiB;QACjB,WAAW;QAEX,4CAA4C;QAC5C,SAAS,CAAC,MAAM;YACd,+BAA+B;YAC/B,uKAAmB,CAAC,cAAc,CAAC,OAAO,WAAW;YACrD,uKAAmB,CAAC,eAAe,CAAC,OAAO,YAAY;YACvD,uKAAmB,CAAC,OAAO,CAAC;YAE5B,+BAA+B;YAC/B,oKAAS,CAAC,YAAY,CAAC,OAAO,WAAW;YAEzC,IAAI;gBACF;gBACA,aAAa,OAAO,WAAW;gBAC/B,cAAc,OAAO,YAAY;gBACjC,iBAAiB;gBACjB,WAAW;YACb;QACF;QAEA,gCAAgC;QAChC,WAAW;YACT,QAAQ,GAAG,CAAC;YACZ,QAAQ,KAAK,CAAC;YAEd,qBAAqB;YACrB,QAAQ,GAAG,CAAC;YACZ,uKAAmB,CAAC,SAAS;YAE7B,mCAAmC;YACnC,QAAQ,GAAG,CAAC;YACZ,oKAAS,CAAC,cAAc;YAExB,QAAQ,GAAG,CAAC;YACZ,IAAI;gBACF,MAAM;gBACN,aAAa;gBACb,cAAc;gBACd,iBAAiB;gBACjB,WAAW;YACb;YAEA,QAAQ,GAAG,CAAC;QACd;QAEA,oBAAoB;QACpB,YAAY,CAAC;YACX,IAAI;gBAAE,WAAW;YAAQ;QAC3B;QAEA,mBAAmB;QACnB,YAAY,CAAC;YACX,MAAM,cAAc,MAAM,IAAI;YAC9B,IAAI,CAAC,aAAa;YAElB,MAAM,cAAc;gBAAE,GAAG,WAAW;gBAAE,GAAG,QAAQ;YAAC;YAClD,uKAAmB,CAAC,OAAO,CAAC;YAE5B,IAAI;gBAAE,MAAM;YAAY;QAC1B;IACF,CAAC,GACD;IACE,MAAM;IACN,YAAY,CAAC,QAAU,CAAC;YACtB,MAAM,MAAM,IAAI;YAChB,aAAa,MAAM,WAAW;YAC9B,cAAc,MAAM,YAAY;YAChC,iBAAiB,MAAM,eAAe;QACxC,CAAC;IACD,oBAAoB,IAAM,CAAC;YACzB,+CAA+C;YAC/C,IAAI,OAAO,aAAa;gBACtB,oKAAS,CAAC,YAAY,CAAC,MAAM,WAAW;YAC1C;QACF;AACF,IAEF;IAAE,MAAM;AAAY","debugId":null}},
    {"offset": {"line": 431, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/api/services/tokenRefreshService.ts"],"sourcesContent":["/**\n * Token Refresh Service\n * Handles automatic token refresh with retry queue to prevent duplicate refreshes\n *\n * Features:\n * - Automatic retry on 401 Unauthorized\n * - Prevents duplicate refresh requests using a queue\n * - Thread-safe refresh operation\n * - Transparent token refresh without user interaction\n */\n\nimport { apiClient } from '../client/api-client';\nimport { useAuthStore } from '@/presentation/store/useAuthStore';\n\nclass TokenRefreshService {\n  private isRefreshing = false;\n  private refreshSubscribers: Array<(token: string) => void> = [];\n\n  /**\n   * Check if token refresh is currently in progress\n   */\n  public get isRefreshInProgress(): boolean {\n    return this.isRefreshing;\n  }\n\n  /**\n   * Add subscriber to be notified when token refresh completes\n   */\n  private subscribeTokenRefresh(callback: (token: string) => void): void {\n    this.refreshSubscribers.push(callback);\n  }\n\n  /**\n   * Notify all subscribers that token refresh is complete\n   */\n  private onTokenRefreshed(token: string): void {\n    this.refreshSubscribers.forEach((callback) => callback(token));\n    this.refreshSubscribers = [];\n  }\n\n  /**\n   * Attempt to refresh the access token\n   * Returns new access token if successful, null otherwise\n   */\n  public async refreshAccessToken(): Promise<string | null> {\n    console.log('üîç [TOKEN REFRESH] refreshAccessToken() called');\n\n    // If refresh is already in progress, queue this request\n    if (this.isRefreshing) {\n      console.log('üîç [TOKEN REFRESH] Refresh already in progress, queueing this request');\n      return new Promise<string | null>((resolve) => {\n        this.subscribeTokenRefresh((token: string) => {\n          console.log('üîç [TOKEN REFRESH] Queued request received token:', token ? 'YES' : 'NO');\n          resolve(token);\n        });\n      });\n    }\n\n    console.log('üîç [TOKEN REFRESH] Starting new refresh operation');\n    this.isRefreshing = true;\n\n    try {\n      console.log('üîÑ [TOKEN REFRESH] Calling POST /Auth/refresh...');\n\n      // Call the refresh endpoint\n      // Note: Refresh token is in HttpOnly cookie, backend reads it automatically\n      const response = await apiClient.post<{\n        accessToken: string;\n        tokenExpiresAt: string;\n      }>('/Auth/refresh', {});\n\n      console.log('üîç [TOKEN REFRESH] Response received:', {\n        hasAccessToken: !!response?.accessToken,\n        tokenExpiresAt: response?.tokenExpiresAt,\n      });\n\n      const { accessToken, tokenExpiresAt } = response;\n\n      console.log('‚úÖ [TOKEN REFRESH] Token refreshed successfully', {\n        expiresAt: tokenExpiresAt,\n        tokenLength: accessToken?.length,\n      });\n\n      // Update auth store with new token\n      const { setAuth, user } = useAuthStore.getState();\n      console.log('üîç [TOKEN REFRESH] Auth store state:', { hasUser: !!user, userId: user?.userId });\n\n      if (user) {\n        console.log('üîç [TOKEN REFRESH] Updating auth store with new token');\n        setAuth(user, {\n          accessToken,\n          refreshToken: '', // Refresh token is in HttpOnly cookie (not in localStorage)\n          expiresIn: 1800, // 30 minutes (matches backend config)\n        });\n      } else {\n        console.warn('‚ö†Ô∏è [TOKEN REFRESH] No user in auth store, cannot update token');\n      }\n\n      // Notify all queued requests\n      console.log('üîç [TOKEN REFRESH] Notifying queued requests, count:', this.refreshSubscribers.length);\n      this.onTokenRefreshed(accessToken);\n\n      this.isRefreshing = false;\n      console.log('üîç [TOKEN REFRESH] Refresh complete, returning new token');\n      return accessToken;\n    } catch (error: any) {\n      console.error('‚ùå [TOKEN REFRESH] Token refresh failed with error:', {\n        message: error?.message,\n        status: error?.statusCode || error?.response?.status,\n        response: error?.response?.data,\n      });\n\n      // Clear auth and notify subscribers\n      this.isRefreshing = false;\n      console.log('üîç [TOKEN REFRESH] Notifying queued requests with empty token');\n      this.onTokenRefreshed('');\n\n      // Clear auth state - user needs to login again\n      console.log('üîç [TOKEN REFRESH] Clearing auth state via clearAuth()');\n      const { clearAuth } = useAuthStore.getState();\n      clearAuth();\n\n      console.log('üîç [TOKEN REFRESH] Returning null');\n      return null;\n    }\n  }\n\n  /**\n   * Retry a failed request after refreshing the token\n   */\n  public async retryRequestAfterRefresh<T>(\n    originalRequest: () => Promise<T>\n  ): Promise<T | null> {\n    const newToken = await this.refreshAccessToken();\n\n    if (!newToken) {\n      throw new Error('Token refresh failed - please login again');\n    }\n\n    // Retry the original request with the new token\n    try {\n      return await originalRequest();\n    } catch (error) {\n      console.error('‚ùå Retry request failed even after token refresh:', error);\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const tokenRefreshService = new TokenRefreshService();\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;AAED;AACA;;;AAEA,MAAM;IACI,eAAe,MAAM;IACrB,qBAAqD,EAAE,CAAC;IAEhE;;GAEC,GACD,IAAW,sBAA+B;QACxC,OAAO,IAAI,CAAC,YAAY;IAC1B;IAEA;;GAEC,GACD,AAAQ,sBAAsB,QAAiC,EAAQ;QACrE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;IAC/B;IAEA;;GAEC,GACD,AAAQ,iBAAiB,KAAa,EAAQ;QAC5C,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,WAAa,SAAS;QACvD,IAAI,CAAC,kBAAkB,GAAG,EAAE;IAC9B;IAEA;;;GAGC,GACD,MAAa,qBAA6C;QACxD,QAAQ,GAAG,CAAC;QAEZ,wDAAwD;QACxD,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,QAAQ,GAAG,CAAC;YACZ,OAAO,IAAI,QAAuB,CAAC;gBACjC,IAAI,CAAC,qBAAqB,CAAC,CAAC;oBAC1B,QAAQ,GAAG,CAAC,qDAAqD,QAAQ,QAAQ;oBACjF,QAAQ;gBACV;YACF;QACF;QAEA,QAAQ,GAAG,CAAC;QACZ,IAAI,CAAC,YAAY,GAAG;QAEpB,IAAI;YACF,QAAQ,GAAG,CAAC;YAEZ,4BAA4B;YAC5B,4EAA4E;YAC5E,MAAM,WAAW,MAAM,oKAAS,CAAC,IAAI,CAGlC,iBAAiB,CAAC;YAErB,QAAQ,GAAG,CAAC,yCAAyC;gBACnD,gBAAgB,CAAC,CAAC,UAAU;gBAC5B,gBAAgB,UAAU;YAC5B;YAEA,MAAM,EAAE,WAAW,EAAE,cAAc,EAAE,GAAG;YAExC,QAAQ,GAAG,CAAC,kDAAkD;gBAC5D,WAAW;gBACX,aAAa,aAAa;YAC5B;YAEA,mCAAmC;YACnC,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,4JAAY,CAAC,QAAQ;YAC/C,QAAQ,GAAG,CAAC,wCAAwC;gBAAE,SAAS,CAAC,CAAC;gBAAM,QAAQ,MAAM;YAAO;YAE5F,IAAI,MAAM;gBACR,QAAQ,GAAG,CAAC;gBACZ,QAAQ,MAAM;oBACZ;oBACA,cAAc;oBACd,WAAW;gBACb;YACF,OAAO;gBACL,QAAQ,IAAI,CAAC;YACf;YAEA,6BAA6B;YAC7B,QAAQ,GAAG,CAAC,wDAAwD,IAAI,CAAC,kBAAkB,CAAC,MAAM;YAClG,IAAI,CAAC,gBAAgB,CAAC;YAEtB,IAAI,CAAC,YAAY,GAAG;YACpB,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT,EAAE,OAAO,OAAY;YACnB,QAAQ,KAAK,CAAC,sDAAsD;gBAClE,SAAS,OAAO;gBAChB,QAAQ,OAAO,cAAc,OAAO,UAAU;gBAC9C,UAAU,OAAO,UAAU;YAC7B;YAEA,oCAAoC;YACpC,IAAI,CAAC,YAAY,GAAG;YACpB,QAAQ,GAAG,CAAC;YACZ,IAAI,CAAC,gBAAgB,CAAC;YAEtB,+CAA+C;YAC/C,QAAQ,GAAG,CAAC;YACZ,MAAM,EAAE,SAAS,EAAE,GAAG,4JAAY,CAAC,QAAQ;YAC3C;YAEA,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT;IACF;IAEA;;GAEC,GACD,MAAa,yBACX,eAAiC,EACd;QACnB,MAAM,WAAW,MAAM,IAAI,CAAC,kBAAkB;QAE9C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,gDAAgD;QAChD,IAAI;YACF,OAAO,MAAM;QACf,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,oDAAoD;YAClE,MAAM;QACR;IACF;AACF;AAGO,MAAM,sBAAsB,IAAI","debugId":null}},
    {"offset": {"line": 559, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/api/client/api-client.ts"],"sourcesContent":["import axios, { AxiosInstance, AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';\r\nimport {\r\n  ApiError,\r\n  NetworkError,\r\n  ValidationError,\r\n  UnauthorizedError,\r\n  ForbiddenError,\r\n  NotFoundError,\r\n  ServerError,\r\n} from './api-errors';\r\nimport { tokenRefreshService } from '../services/tokenRefreshService';\r\n\r\n/**\r\n * API Client Configuration\r\n */\r\nexport interface ApiClientConfig {\r\n  baseURL: string;\r\n  timeout?: number;\r\n  headers?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Callback for handling 401 Unauthorized errors (token expiration)\r\n */\r\ntype UnauthorizedCallback = () => void;\r\n\r\n/**\r\n * API Client\r\n * Singleton pattern for managing HTTP requests\r\n */\r\nexport class ApiClient {\r\n  private static instance: ApiClient;\r\n  private axiosInstance: AxiosInstance;\r\n  private authToken: string | null = null;\r\n  private onUnauthorized: UnauthorizedCallback | null = null;\r\n\r\n  private constructor(config?: Partial<ApiClientConfig>) {\r\n    const baseURL = config?.baseURL || process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api';\r\n\r\n    this.axiosInstance = axios.create({\r\n      baseURL,\r\n      timeout: config?.timeout || 30000,\r\n      withCredentials: true, // Enable credentials for CORS requests\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        ...config?.headers,\r\n      },\r\n    });\r\n\r\n    this.setupInterceptors();\r\n  }\r\n\r\n  /**\r\n   * Get singleton instance\r\n   */\r\n  public static getInstance(config?: Partial<ApiClientConfig>): ApiClient {\r\n    if (!ApiClient.instance) {\r\n      ApiClient.instance = new ApiClient(config);\r\n    }\r\n    return ApiClient.instance;\r\n  }\r\n\r\n  /**\r\n   * Setup request and response interceptors\r\n   */\r\n  private setupInterceptors(): void {\r\n    // Request interceptor\r\n    this.axiosInstance.interceptors.request.use(\r\n      (config) => {\r\n        // Add auth token if available\r\n        if (this.authToken) {\r\n          config.headers.Authorization = `Bearer ${this.authToken}`;\r\n        }\r\n\r\n        // PHASE 6A.10: Comprehensive request logging for debugging\r\n        const authHeader = config.headers.Authorization;\r\n        const authValue = typeof authHeader === 'string' && authHeader.startsWith('Bearer ')\r\n          ? `Bearer ${authHeader.substring(7, 30)}...`\r\n          : 'Not set';\r\n\r\n        console.log('üöÄ API Request:', {\r\n          method: config.method?.toUpperCase(),\r\n          url: config.url,\r\n          baseURL: config.baseURL,\r\n          fullURL: `${config.baseURL}${config.url}`,\r\n          headers: {\r\n            'Content-Type': config.headers['Content-Type'],\r\n            'Authorization': authValue,\r\n            'Origin': config.headers.Origin || (typeof window !== 'undefined' ? window.location.origin : 'SSR'),\r\n          },\r\n          data: config.data ? JSON.stringify(config.data).substring(0, 200) : 'No data',\r\n        });\r\n\r\n        return config;\r\n      },\r\n      (error) => {\r\n        console.error('‚ùå Request Interceptor Error:', error);\r\n        return Promise.reject(this.handleError(error));\r\n      }\r\n    );\r\n\r\n    // Response interceptor\r\n    this.axiosInstance.interceptors.response.use(\r\n      (response) => {\r\n        // PHASE 6A.10: Log successful responses\r\n        console.log('‚úÖ API Response Success:', {\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          url: response.config.url,\r\n          headers: {\r\n            'Access-Control-Allow-Origin': response.headers['access-control-allow-origin'],\r\n            'Access-Control-Allow-Credentials': response.headers['access-control-allow-credentials'],\r\n            'Content-Type': response.headers['content-type'],\r\n          },\r\n          dataSize: JSON.stringify(response.data || {}).length,\r\n        });\r\n        return response;\r\n      },\r\n      async (error) => {\r\n        const originalRequest = error.config;\r\n\r\n        console.log('üîç [AUTH INTERCEPTOR] Response error received:', {\r\n          status: error.response?.status,\r\n          url: originalRequest?.url,\r\n          method: originalRequest?.method,\r\n          hasResponse: !!error.response,\r\n          alreadyRetried: !!originalRequest._retry,\r\n          errorMessage: error.message,\r\n        });\r\n\r\n        // Check if this is a 401 error and we haven't already retried\r\n        if (error.response?.status === 401 && !originalRequest._retry) {\r\n          console.log('üîç [AUTH INTERCEPTOR] 401 Unauthorized detected');\r\n\r\n          // Skip refresh for auth endpoints (login, register, refresh)\r\n          const isAuthEndpoint = originalRequest.url?.includes('/Auth/login') ||\r\n                                  originalRequest.url?.includes('/Auth/register') ||\r\n                                  originalRequest.url?.includes('/Auth/refresh');\r\n\r\n          console.log('üîç [AUTH INTERCEPTOR] Is auth endpoint?', isAuthEndpoint);\r\n\r\n          if (!isAuthEndpoint) {\r\n            console.log('üîì [AUTH INTERCEPTOR] Attempting token refresh...');\r\n\r\n            // Mark that we've tried to refresh for this request\r\n            originalRequest._retry = true;\r\n\r\n            try {\r\n              // Attempt to refresh the token\r\n              console.log('üîç [AUTH INTERCEPTOR] Calling tokenRefreshService.refreshAccessToken()');\r\n              const newToken = await tokenRefreshService.refreshAccessToken();\r\n\r\n              console.log('üîç [AUTH INTERCEPTOR] Token refresh result:', newToken ? 'SUCCESS' : 'FAILED (null)');\r\n\r\n              if (newToken) {\r\n                // Update the Authorization header with the new token\r\n                originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\r\n\r\n                console.log('üîÑ [AUTH INTERCEPTOR] Retrying request with new token...');\r\n\r\n                // Retry the original request\r\n                return this.axiosInstance(originalRequest);\r\n              } else {\r\n                console.error('‚ùå [AUTH INTERCEPTOR] Token refresh returned null - triggering logout');\r\n                if (this.onUnauthorized) {\r\n                  console.log('üîç [AUTH INTERCEPTOR] Calling onUnauthorized callback');\r\n                  this.onUnauthorized();\r\n                }\r\n                return Promise.reject(new Error('Token refresh returned null'));\r\n              }\r\n            } catch (refreshError) {\r\n              console.error('‚ùå [AUTH INTERCEPTOR] Token refresh threw error:', refreshError);\r\n              console.error('‚ùå [AUTH INTERCEPTOR] Clearing auth and redirecting to login');\r\n              // Token refresh failed - trigger logout callback to clear auth state\r\n              if (this.onUnauthorized) {\r\n                console.log('üîç [AUTH INTERCEPTOR] Calling onUnauthorized callback after refresh error');\r\n                this.onUnauthorized();\r\n              }\r\n              return Promise.reject(refreshError);\r\n            }\r\n          } else {\r\n            console.log('üîç [AUTH INTERCEPTOR] Skipping token refresh for auth endpoint');\r\n          }\r\n        }\r\n\r\n        // PHASE 6A.10: Comprehensive error logging\r\n        console.error('‚ùå API Response Error:', {\r\n          message: error.message,\r\n          name: error.name,\r\n          code: error.code,\r\n          request: error.request ? {\r\n            method: error.config?.method,\r\n            url: error.config?.url,\r\n            headers: error.config?.headers,\r\n          } : 'No request object',\r\n          response: error.response ? {\r\n            status: error.response.status,\r\n            statusText: error.response.statusText,\r\n            headers: error.response.headers,\r\n            data: error.response.data,\r\n          } : 'No response object',\r\n          isAxiosError: axios.isAxiosError(error),\r\n        });\r\n        return Promise.reject(this.handleError(error));\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle errors and convert to custom error types\r\n   */\r\n  private handleError(error: unknown): ApiError {\r\n    if (axios.isAxiosError(error)) {\r\n      const axiosError = error as AxiosError<any>;\r\n\r\n      // Network error (no response)\r\n      if (!axiosError.response) {\r\n        return new NetworkError(axiosError.message || 'Network error occurred');\r\n      }\r\n\r\n      const { status, data } = axiosError.response;\r\n\r\n      // Extract error message\r\n      const message = data?.message || data?.error || axiosError.message || 'An error occurred';\r\n\r\n      // Handle specific status codes\r\n      switch (status) {\r\n        case 400:\r\n          return new ValidationError(message, data?.errors || data?.validationErrors, axiosError.response);\r\n        case 401:\r\n          // Token expired or invalid\r\n          // Note: onUnauthorized callback is already triggered in the response interceptor\r\n          // after token refresh fails, so we don't call it again here to avoid double redirects\r\n          return new UnauthorizedError(message);\r\n        case 403:\r\n          return new ForbiddenError(message);\r\n        case 404:\r\n          return new NotFoundError(message);\r\n        case 500:\r\n        case 502:\r\n        case 503:\r\n        case 504:\r\n          return new ServerError(message, status);\r\n        default:\r\n          return new ApiError(message, status, undefined, axiosError.response);\r\n      }\r\n    }\r\n\r\n    // Unknown error\r\n    if (error instanceof Error) {\r\n      return new ApiError(error.message);\r\n    }\r\n\r\n    return new ApiError('An unknown error occurred');\r\n  }\r\n\r\n  /**\r\n   * Set callback for handling 401 Unauthorized errors\r\n   */\r\n  public setUnauthorizedCallback(callback: UnauthorizedCallback): void {\r\n    this.onUnauthorized = callback;\r\n  }\r\n\r\n  /**\r\n   * Set authentication token\r\n   */\r\n  public setAuthToken(token: string): void {\r\n    this.authToken = token;\r\n  }\r\n\r\n  /**\r\n   * Clear authentication token\r\n   */\r\n  public clearAuthToken(): void {\r\n    this.authToken = null;\r\n  }\r\n\r\n  /**\r\n   * GET request\r\n   */\r\n  public async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.get(url, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * POST request\r\n   */\r\n  public async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.post(url, data, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * PUT request\r\n   */\r\n  public async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.put(url, data, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * PATCH request\r\n   */\r\n  public async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.patch(url, data, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * DELETE request\r\n   */\r\n  public async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.delete(url, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * POST request with multipart/form-data (for file uploads)\r\n   * Note: Deletes Content-Type to let browser set multipart/form-data with boundary\r\n   */\r\n  public async postMultipart<T = any>(\r\n    url: string,\r\n    formData: FormData,\r\n    config?: AxiosRequestConfig\r\n  ): Promise<T> {\r\n    // Delete Content-Type header to let browser set multipart/form-data with boundary\r\n    const response: AxiosResponse<T> = await this.axiosInstance.post(url, formData, {\r\n      ...config,\r\n      headers: {\r\n        ...config?.headers,\r\n        'Content-Type': undefined, // Delete Content-Type so browser sets it correctly\r\n      },\r\n    });\r\n    return response.data;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const apiClient = ApiClient.getInstance();\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 820, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/utils/jwtDecoder.ts"],"sourcesContent":["/**\n * JWT Decoder Utility\n * Decodes JWT tokens to extract expiration time and other claims\n *\n * Note: This is NOT for token validation (that's done on the server)\n * This is only for reading token expiration to enable proactive refresh\n */\n\nexport interface DecodedJwt {\n  exp: number; // Expiration time (Unix timestamp in seconds)\n  iat: number; // Issued at (Unix timestamp in seconds)\n  sub?: string; // Subject (usually user ID)\n  email?: string;\n  role?: string;\n  [key: string]: any;\n}\n\n/**\n * Decode a JWT token (without validation)\n * Returns null if token is invalid or malformed\n */\nexport function decodeJwt(token: string): DecodedJwt | null {\n  if (!token) {\n    return null;\n  }\n\n  try {\n    // JWT format: header.payload.signature\n    const parts = token.split('.');\n\n    if (parts.length !== 3) {\n      console.error('Invalid JWT format - expected 3 parts');\n      return null;\n    }\n\n    // Decode the payload (second part)\n    const payload = parts[1];\n\n    // Base64URL decode\n    const base64 = payload.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split('')\n        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\n        .join('')\n    );\n\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.error('Failed to decode JWT:', error);\n    return null;\n  }\n}\n\n/**\n * Get token expiration time in milliseconds\n * Returns null if token is invalid\n */\nexport function getTokenExpiration(token: string): number | null {\n  const decoded = decodeJwt(token);\n\n  if (!decoded || !decoded.exp) {\n    return null;\n  }\n\n  // Convert from seconds to milliseconds\n  return decoded.exp * 1000;\n}\n\n/**\n * Check if token is expired\n */\nexport function isTokenExpired(token: string): boolean {\n  const expiration = getTokenExpiration(token);\n\n  if (!expiration) {\n    return true; // Treat invalid tokens as expired\n  }\n\n  return Date.now() >= expiration;\n}\n\n/**\n * Get time remaining until token expires (in milliseconds)\n * Returns 0 if token is already expired\n * Returns null if token is invalid\n */\nexport function getTimeUntilExpiration(token: string): number | null {\n  const expiration = getTokenExpiration(token);\n\n  if (!expiration) {\n    return null;\n  }\n\n  const timeRemaining = expiration - Date.now();\n  return Math.max(0, timeRemaining);\n}\n\n/**\n * Calculate when to refresh token (5 minutes before expiration)\n * Returns timestamp in milliseconds, or null if token is invalid\n */\nexport function getRefreshTime(token: string): number | null {\n  const expiration = getTokenExpiration(token);\n\n  if (!expiration) {\n    return null;\n  }\n\n  // Refresh 5 minutes (300,000 ms) before expiration\n  const refreshBuffer = 5 * 60 * 1000;\n  return expiration - refreshBuffer;\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;;;;;AAeM,SAAS,UAAU,KAAa;IACrC,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,IAAI;QACF,uCAAuC;QACvC,MAAM,QAAQ,MAAM,KAAK,CAAC;QAE1B,IAAI,MAAM,MAAM,KAAK,GAAG;YACtB,QAAQ,KAAK,CAAC;YACd,OAAO;QACT;QAEA,mCAAmC;QACnC,MAAM,UAAU,KAAK,CAAC,EAAE;QAExB,mBAAmB;QACnB,MAAM,SAAS,QAAQ,OAAO,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM;QACxD,MAAM,cAAc,mBAClB,KAAK,QACF,KAAK,CAAC,IACN,GAAG,CAAC,CAAC,IAAM,MAAM,CAAC,OAAO,EAAE,UAAU,CAAC,GAAG,QAAQ,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,IAC9D,IAAI,CAAC;QAGV,OAAO,KAAK,KAAK,CAAC;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO;IACT;AACF;AAMO,SAAS,mBAAmB,KAAa;IAC9C,MAAM,UAAU,UAAU;IAE1B,IAAI,CAAC,WAAW,CAAC,QAAQ,GAAG,EAAE;QAC5B,OAAO;IACT;IAEA,uCAAuC;IACvC,OAAO,QAAQ,GAAG,GAAG;AACvB;AAKO,SAAS,eAAe,KAAa;IAC1C,MAAM,aAAa,mBAAmB;IAEtC,IAAI,CAAC,YAAY;QACf,OAAO,MAAM,kCAAkC;IACjD;IAEA,OAAO,KAAK,GAAG,MAAM;AACvB;AAOO,SAAS,uBAAuB,KAAa;IAClD,MAAM,aAAa,mBAAmB;IAEtC,IAAI,CAAC,YAAY;QACf,OAAO;IACT;IAEA,MAAM,gBAAgB,aAAa,KAAK,GAAG;IAC3C,OAAO,KAAK,GAAG,CAAC,GAAG;AACrB;AAMO,SAAS,eAAe,KAAa;IAC1C,MAAM,aAAa,mBAAmB;IAEtC,IAAI,CAAC,YAAY;QACf,OAAO;IACT;IAEA,mDAAmD;IACnD,MAAM,gBAAgB,IAAI,KAAK;IAC/B,OAAO,aAAa;AACtB","debugId":null}},
    {"offset": {"line": 896, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/presentation/hooks/useTokenRefresh.ts"],"sourcesContent":["/**\n * useTokenRefresh Hook\n * Proactively refreshes JWT token before it expires\n *\n * Usage: Call this hook in your root layout or app component\n * Example: useTokenRefresh();\n *\n * Features:\n * - Automatically refreshes token 5 minutes before expiration\n * - Clears timer on logout\n * - Handles edge cases (invalid tokens, no token, etc.)\n */\n\nimport { useEffect, useRef } from 'react';\nimport { useAuthStore } from '../store/useAuthStore';\nimport { getTimeUntilExpiration, getRefreshTime } from '@/infrastructure/utils/jwtDecoder';\nimport { tokenRefreshService } from '@/infrastructure/api/services/tokenRefreshService';\n\nexport function useTokenRefresh() {\n  const { accessToken, isAuthenticated } = useAuthStore();\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    // Clear any existing timer\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n\n    // Only set up refresh if user is authenticated and has a token\n    if (!isAuthenticated || !accessToken) {\n      console.log('‚è∏Ô∏è Token refresh timer: Not authenticated or no token');\n      return;\n    }\n\n    const refreshTime = getRefreshTime(accessToken);\n\n    if (!refreshTime) {\n      console.warn('‚ö†Ô∏è Unable to determine token refresh time - token may be invalid');\n      return;\n    }\n\n    const now = Date.now();\n    const timeUntilRefresh = refreshTime - now;\n\n    // If token should already be refreshed, refresh immediately\n    if (timeUntilRefresh <= 0) {\n      console.log('‚ö° Token refresh overdue - refreshing immediately');\n      tokenRefreshService.refreshAccessToken().catch((error) => {\n        console.error('‚ùå Immediate token refresh failed:', error);\n      });\n      return;\n    }\n\n    console.log('‚è∞ Token refresh scheduled in:', {\n      minutes: Math.round(timeUntilRefresh / 60000),\n      seconds: Math.round(timeUntilRefresh / 1000),\n    });\n\n    // Set timer to refresh token\n    timerRef.current = setTimeout(() => {\n      console.log('üîÑ Proactive token refresh triggered');\n      tokenRefreshService.refreshAccessToken().catch((error) => {\n        console.error('‚ùå Proactive token refresh failed:', error);\n      });\n    }, timeUntilRefresh);\n\n    // Cleanup function\n    return () => {\n      if (timerRef.current) {\n        console.log('üßπ Clearing token refresh timer');\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n    };\n  }, [accessToken, isAuthenticated]);\n\n  // Also check token expiration on mount and every minute\n  useEffect(() => {\n    if (!isAuthenticated || !accessToken) {\n      return;\n    }\n\n    const checkInterval = setInterval(() => {\n      const timeRemaining = getTimeUntilExpiration(accessToken);\n\n      if (timeRemaining === null) {\n        console.warn('‚ö†Ô∏è Invalid token detected in periodic check');\n        return;\n      }\n\n      // If less than 5 minutes remaining, refresh now\n      if (timeRemaining < 5 * 60 * 1000 && timeRemaining > 0) {\n        console.log('‚ö° Less than 5 minutes remaining - refreshing token');\n        tokenRefreshService.refreshAccessToken().catch((error) => {\n          console.error('‚ùå Periodic token refresh failed:', error);\n        });\n      }\n    }, 60 * 1000); // Check every minute\n\n    return () => clearInterval(checkInterval);\n  }, [accessToken, isAuthenticated]);\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;CAWC;;;;AAED;AACA;AACA;AACA;;;;;AAEO,SAAS;IACd,MAAM,EAAE,WAAW,EAAE,eAAe,EAAE,GAAG,IAAA,4JAAY;IACrD,MAAM,WAAW,IAAA,+MAAM,EAAwB;IAE/C,IAAA,kNAAS,EAAC;QACR,2BAA2B;QAC3B,IAAI,SAAS,OAAO,EAAE;YACpB,aAAa,SAAS,OAAO;YAC7B,SAAS,OAAO,GAAG;QACrB;QAEA,+DAA+D;QAC/D,IAAI,CAAC,mBAAmB,CAAC,aAAa;YACpC,QAAQ,GAAG,CAAC;YACZ;QACF;QAEA,MAAM,cAAc,IAAA,8JAAc,EAAC;QAEnC,IAAI,CAAC,aAAa;YAChB,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,mBAAmB,cAAc;QAEvC,4DAA4D;QAC5D,IAAI,oBAAoB,GAAG;YACzB,QAAQ,GAAG,CAAC;YACZ,sLAAmB,CAAC,kBAAkB,GAAG,KAAK,CAAC,CAAC;gBAC9C,QAAQ,KAAK,CAAC,qCAAqC;YACrD;YACA;QACF;QAEA,QAAQ,GAAG,CAAC,iCAAiC;YAC3C,SAAS,KAAK,KAAK,CAAC,mBAAmB;YACvC,SAAS,KAAK,KAAK,CAAC,mBAAmB;QACzC;QAEA,6BAA6B;QAC7B,SAAS,OAAO,GAAG,WAAW;YAC5B,QAAQ,GAAG,CAAC;YACZ,sLAAmB,CAAC,kBAAkB,GAAG,KAAK,CAAC,CAAC;gBAC9C,QAAQ,KAAK,CAAC,qCAAqC;YACrD;QACF,GAAG;QAEH,mBAAmB;QACnB,OAAO;YACL,IAAI,SAAS,OAAO,EAAE;gBACpB,QAAQ,GAAG,CAAC;gBACZ,aAAa,SAAS,OAAO;gBAC7B,SAAS,OAAO,GAAG;YACrB;QACF;IACF,GAAG;QAAC;QAAa;KAAgB;IAEjC,wDAAwD;IACxD,IAAA,kNAAS,EAAC;QACR,IAAI,CAAC,mBAAmB,CAAC,aAAa;YACpC;QACF;QAEA,MAAM,gBAAgB,YAAY;YAChC,MAAM,gBAAgB,IAAA,sKAAsB,EAAC;YAE7C,IAAI,kBAAkB,MAAM;gBAC1B,QAAQ,IAAI,CAAC;gBACb;YACF;YAEA,gDAAgD;YAChD,IAAI,gBAAgB,IAAI,KAAK,QAAQ,gBAAgB,GAAG;gBACtD,QAAQ,GAAG,CAAC;gBACZ,sLAAmB,CAAC,kBAAkB,GAAG,KAAK,CAAC,CAAC;oBAC9C,QAAQ,KAAK,CAAC,oCAAoC;gBACpD;YACF;QACF,GAAG,KAAK,OAAO,qBAAqB;QAEpC,OAAO,IAAM,cAAc;IAC7B,GAAG;QAAC;QAAa;KAAgB;AACnC","debugId":null}},
    {"offset": {"line": 1000, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/presentation/providers/AuthProvider.tsx"],"sourcesContent":["'use client';\n\nimport { useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { apiClient } from '@/infrastructure/api/client/api-client';\nimport { useAuthStore } from '@/presentation/store/useAuthStore';\nimport { useTokenRefresh } from '@/presentation/hooks/useTokenRefresh';\n\n/**\n * AuthProvider Component\n * Sets up global authentication features:\n *\n * 1. Global 401 error handling for automatic logout on token expiration\n * 2. Proactive token refresh - automatically refreshes token before expiration\n *\n * This component:\n * - Registers a callback with the API client to handle 401 Unauthorized errors\n * - Sets up proactive token refresh timer (refreshes 5 minutes before expiry)\n * - When a 401 occurs (token expired), it clears auth and redirects to login\n * - Prevents multiple redirects with a flag\n */\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const router = useRouter();\n  const clearAuth = useAuthStore((state) => state.clearAuth);\n\n  // Phase AUTH-IMPROVEMENT: Proactive token refresh\n  // Automatically refreshes token 5 minutes before expiration\n  useTokenRefresh();\n\n  useEffect(() => {\n    let isHandling401 = false;\n\n    // Set up 401 error handler\n    apiClient.setUnauthorizedCallback(() => {\n      console.log('üîç [AUTH PROVIDER] onUnauthorized callback triggered');\n      console.log('üîç [AUTH PROVIDER] isHandling401:', isHandling401);\n\n      // Prevent multiple simultaneous logout/redirect calls\n      if (isHandling401) {\n        console.log('üîç [AUTH PROVIDER] Already handling 401, skipping');\n        return;\n      }\n      isHandling401 = true;\n\n      console.log('üîç [AUTH PROVIDER] Calling clearAuth()');\n      // Clear authentication state\n      clearAuth();\n\n      console.log('üîç [AUTH PROVIDER] Redirecting to /login');\n      // Redirect to login page\n      router.push('/login');\n\n      // Reset flag after redirect\n      setTimeout(() => {\n        isHandling401 = false;\n        console.log('üîç [AUTH PROVIDER] Reset isHandling401 flag');\n      }, 1000);\n    });\n  }, [router, clearAuth]);\n\n  return <>{children}</>;\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AANA;;;;;;;AAqBO,SAAS,aAAa,EAAE,QAAQ,EAAiC;IACtE,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,YAAY,IAAA,4JAAY,EAAC,CAAC,QAAU,MAAM,SAAS;IAEzD,kDAAkD;IAClD,4DAA4D;IAC5D,IAAA,kKAAe;IAEf,IAAA,kNAAS,EAAC;QACR,IAAI,gBAAgB;QAEpB,2BAA2B;QAC3B,oKAAS,CAAC,uBAAuB,CAAC;YAChC,QAAQ,GAAG,CAAC;YACZ,QAAQ,GAAG,CAAC,qCAAqC;YAEjD,sDAAsD;YACtD,IAAI,eAAe;gBACjB,QAAQ,GAAG,CAAC;gBACZ;YACF;YACA,gBAAgB;YAEhB,QAAQ,GAAG,CAAC;YACZ,6BAA6B;YAC7B;YAEA,QAAQ,GAAG,CAAC;YACZ,yBAAyB;YACzB,OAAO,IAAI,CAAC;YAEZ,4BAA4B;YAC5B,WAAW;gBACT,gBAAgB;gBAChB,QAAQ,GAAG,CAAC;YACd,GAAG;QACL;IACF,GAAG;QAAC;QAAQ;KAAU;IAEtB,qBAAO;kBAAG;;AACZ","debugId":null}},
    {"offset": {"line": 1059, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/app/providers.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useState } from 'react';\r\nimport { QueryClientProvider } from '@tanstack/react-query';\r\nimport { makeQueryClient } from '@/lib/react-query';\r\nimport { AuthProvider } from '@/presentation/providers/AuthProvider';\r\n\r\n/**\r\n * Providers Component\r\n *\r\n * CRITICAL PATTERN for Next.js 16 + React 19 + React Query v5:\r\n *\r\n * We MUST use useState with an initialization function to create the QueryClient.\r\n * This ensures the client is created ONCE on component mount and survives React 19's\r\n * automatic batching during hydration.\r\n *\r\n * DO NOT use module-level singletons or external functions - this breaks during\r\n * SSR/hydration and causes queries to never execute.\r\n *\r\n * See: https://tanstack.com/query/latest/docs/framework/react/guides/nextjs\r\n *\r\n * AuthProvider: Sets up global 401 error handling for automatic logout on token expiration\r\n */\r\nexport function Providers({ children }: { children: React.ReactNode }) {\r\n  // ‚úÖ CORRECT: Use useState with initialization function\r\n  // This creates the QueryClient ONCE on client mount\r\n  // and ensures it survives React 19's automatic batching during hydration\r\n  const [queryClient] = useState(() => makeQueryClient());\r\n\r\n  return (\r\n    <QueryClientProvider client={queryClient}>\r\n      <AuthProvider>\r\n        {children}\r\n      </AuthProvider>\r\n    </QueryClientProvider>\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAuBO,SAAS,UAAU,EAAE,QAAQ,EAAiC;IACnE,uDAAuD;IACvD,oDAAoD;IACpD,yEAAyE;IACzE,MAAM,CAAC,YAAY,GAAG,IAAA,iNAAQ,EAAC,IAAM,IAAA,+IAAe;IAEpD,qBACE,8OAAC,6MAAmB;QAAC,QAAQ;kBAC3B,cAAA,8OAAC,iKAAY;sBACV;;;;;;;;;;;AAIT","debugId":null}}]
}