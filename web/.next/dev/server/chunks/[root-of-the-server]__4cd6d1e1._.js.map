{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/app/api/proxy/%5B...path%5D/route.ts"],"sourcesContent":["/**\n * Next.js API Route Proxy for Staging Backend\n *\n * Purpose: Forward API requests from localhost:3000 to Azure staging backend\n *\n * Why needed:\n * - Frontend: http://localhost:3000 (HTTP)\n * - Backend: https://staging.azurecontainerapps.io (HTTPS)\n * - Browsers block Secure cookies from being sent over HTTP\n * - This proxy makes browser see same-origin (localhost:3000/api/proxy/...)\n *\n * How it works:\n * - Browser sends request to localhost:3000/api/proxy/Auth/login (same-origin HTTP)\n * - Next.js server forwards to staging backend over HTTPS (server-to-server, no browser restrictions)\n * - Backend sets Secure cookies in response\n * - Next.js server receives them and forwards to browser\n * - Browser stores cookies under localhost:3000 domain\n * - Subsequent requests include cookies (same-origin)\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\n\n// IMPORTANT: Use explicit staging URL, NOT NEXT_PUBLIC_API_URL (which points to /api/proxy)\n// Always use the staging backend URL (local development should still use Azure staging for API calls)\nconst BACKEND_URL = 'https://lankaconnect-api-staging.politebay-79d6e8a2.eastus2.azurecontainerapps.io/api';\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ path: string[] }> }\n) {\n  const resolvedParams = await params;\n  return forwardRequest(request, resolvedParams.path, 'GET');\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ path: string[] }> }\n) {\n  const resolvedParams = await params;\n  return forwardRequest(request, resolvedParams.path, 'POST');\n}\n\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: Promise<{ path: string[] }> }\n) {\n  const resolvedParams = await params;\n  return forwardRequest(request, resolvedParams.path, 'PUT');\n}\n\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ path: string[] }> }\n) {\n  const resolvedParams = await params;\n  return forwardRequest(request, resolvedParams.path, 'DELETE');\n}\n\nexport async function PATCH(\n  request: NextRequest,\n  { params }: { params: Promise<{ path: string[] }> }\n) {\n  const resolvedParams = await params;\n  return forwardRequest(request, resolvedParams.path, 'PATCH');\n}\n\nasync function forwardRequest(\n  request: NextRequest,\n  pathSegments: string[],\n  method: string\n) {\n  try {\n    const path = pathSegments.join('/');\n    // CRITICAL FIX: Preserve query string parameters for filtering, pagination, etc.\n    // Without this, GET requests with query params (e.g., /events?category=0) lose their filters\n    const queryString = request.nextUrl.search; // Returns \"?param=value\" or empty string\n    const targetUrl = `${BACKEND_URL}/${path}${queryString}`;\n\n    // Get Content-Type to detect multipart/form-data\n    const contentType = request.headers.get('content-type');\n    const isMultipart = contentType?.includes('multipart/form-data');\n\n    // Get request body if present\n    // CRITICAL: For multipart/form-data, stream body as-is to preserve binary data and boundary\n    let body: BodyInit | undefined;\n    if (method !== 'GET' && method !== 'DELETE') {\n      if (isMultipart) {\n        // Stream multipart body as-is (don't read as text - corrupts binary data)\n        body = request.body ?? undefined;\n      } else {\n        // For JSON, read as text\n        try {\n          body = await request.text();\n        } catch {\n          body = undefined;\n        }\n      }\n    }\n\n    // Forward cookies from request\n    const cookies = request.cookies.getAll();\n    const cookieHeader = cookies.map(c => `${c.name}=${c.value}`).join('; ');\n\n    // PHASE 6A.10: Detailed cookie forwarding logging for token refresh debugging\n    const isAuthRefresh = path === 'Auth/refresh';\n    const hasRefreshToken = cookies.some(c => c.name === 'refreshToken');\n\n    if (isAuthRefresh) {\n      console.log('ðŸ” [PROXY] Token Refresh Request Detected', {\n        path,\n        method,\n        allCookies: cookies.map(c => ({ name: c.name, valueLength: c.value.length })),\n        hasRefreshToken,\n        refreshTokenValue: hasRefreshToken ? cookies.find(c => c.name === 'refreshToken')?.value.substring(0, 30) + '...' : 'NOT FOUND',\n        cookieHeaderLength: cookieHeader.length,\n        totalCookies: cookies.length,\n      });\n    }\n\n    // Build headers for backend request\n    const headers: HeadersInit = {\n      // CRITICAL: Preserve exact Content-Type for multipart (includes boundary parameter)\n      'Content-Type': contentType || 'application/json',\n      'Accept': request.headers.get('accept') || 'application/json',\n    };\n\n    // Forward Authorization header if present\n    const authHeader = request.headers.get('authorization');\n    if (authHeader) {\n      headers['Authorization'] = authHeader;\n    }\n\n    // Forward cookies\n    if (cookieHeader) {\n      headers['Cookie'] = cookieHeader;\n    }\n\n    // PHASE 6A.10: Log headers being sent to backend for token refresh\n    if (isAuthRefresh) {\n      console.log('ðŸ” [PROXY] Headers being sent to backend:', {\n        'Content-Type': headers['Content-Type'],\n        'Authorization': authHeader ? `Bearer ${authHeader.toString().substring(7, 30)}...` : 'Not present',\n        'Cookie': cookieHeader ? `${cookieHeader.substring(0, 100)}...` : 'Not present',\n        cookieHeaderFull: cookieHeader,\n      });\n    }\n\n    console.log(`[Proxy] ${method} ${targetUrl}`, {\n      contentType,\n      isMultipart,\n      hasBody: !!body,\n      isAuthRefresh,\n      hasRefreshToken,\n    });\n\n    // Build fetch options\n    const fetchOptions: RequestInit = {\n      method,\n      headers,\n      body,\n      credentials: 'include', // Important: include cookies\n      // CRITICAL: Large file uploads (videos up to 100MB) need longer timeout\n      // Backend has 5-minute timeout for video uploads, proxy needs at least as long\n      // Add buffer for network overhead: 10 minutes total\n      signal: AbortSignal.timeout(600000), // 10 minutes\n    };\n\n    // Only add duplex for multipart/form-data streaming\n    if (isMultipart && body) {\n      // @ts-ignore - duplex is required for streaming request bodies but not in TS types yet\n      fetchOptions.duplex = 'half';\n    }\n\n    // Make request to backend\n    const response = await fetch(targetUrl, fetchOptions);\n\n    // PHASE 6A.10: Log backend response for token refresh\n    if (isAuthRefresh) {\n      console.log('ðŸ” [PROXY] Backend Response:', {\n        status: response.status,\n        statusText: response.statusText,\n        headers: {\n          'Content-Type': response.headers.get('content-type'),\n          'Set-Cookie': response.headers.get('set-cookie'),\n        },\n        setCookieHeaders: response.headers.getSetCookie?.() || [],\n      });\n    }\n\n    // Get response body - handle empty responses (e.g., successful free event registration returns null)\n    const responseText = await response.text();\n    let responseBody: any;\n\n    // Special handling for RSVP endpoint\n    const isRsvpEndpoint = path.includes('events') && path.endsWith('rsvp');\n\n    // Phase 6A.13: Log set-primary requests for debugging\n    const isSetPrimaryEndpoint = path.includes('set-primary');\n    if (isSetPrimaryEndpoint) {\n      console.log('[Proxy] Set Primary Image Response:', {\n        path,\n        status: response.status,\n        statusText: response.statusText,\n        responseText: responseText?.substring(0, 500),\n      });\n    }\n\n    // Handle empty/null responses\n    if (!responseText || responseText === 'null' || responseText.trim() === '') {\n      console.log('[Proxy] Empty response body received (normal for free event registration)');\n      responseBody = null;\n    } else {\n      try {\n        responseBody = JSON.parse(responseText);\n      } catch {\n        responseBody = responseText;\n      }\n    }\n\n    // Log RSVP responses for debugging\n    if (isRsvpEndpoint) {\n      console.log('[Proxy] RSVP Response:', {\n        status: response.status,\n        responseBody,\n        responseText: responseText?.substring(0, 100),\n        isNull: responseBody === null,\n        isEmpty: !responseText || responseText.trim() === '',\n      });\n    }\n\n    // PHASE 6A.10: Log response body for token refresh\n    if (isAuthRefresh) {\n      console.log('ðŸ” [PROXY] Backend Response Body:', {\n        status: response.status,\n        bodyType: typeof responseBody,\n        hasAccessToken: responseBody?.accessToken ? 'YES' : 'NO',\n        hasError: responseBody?.error ? 'YES' : 'NO',\n        errorMessage: responseBody?.error || responseBody?.message || 'None',\n        body: responseBody,\n      });\n    }\n\n    // Create Next.js response - handle different response types\n    let nextResponse: NextResponse;\n\n    // Special handling for 204 No Content - MUST NOT have a body per HTTP spec\n    if (response.status === 204) {\n      nextResponse = new NextResponse(null, {\n        status: 204,\n        statusText: 'No Content',\n      });\n    } else {\n      // For other responses, return JSON\n      // Return 'null' as JSON string for null responses (not empty string)\n      const responseContent = responseBody === null ? 'null' : JSON.stringify(responseBody);\n      nextResponse = new NextResponse(responseContent, {\n        status: response.status,\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      });\n    }\n\n    // Forward Set-Cookie headers from backend\n    const setCookieHeaders = response.headers.getSetCookie?.() || [];\n    setCookieHeaders.forEach(cookie => {\n      // Parse cookie and convert Secure/SameSite for localhost\n      const cookieParts = cookie.split(';').map(p => p.trim());\n      const [nameValue, ...attributes] = cookieParts;\n\n      // Rebuild cookie without Secure flag for localhost\n      const newAttributes = attributes\n        .filter(attr => !attr.toLowerCase().startsWith('secure'))\n        .filter(attr => !attr.toLowerCase().startsWith('samesite=none'));\n\n      // Add SameSite=Lax for localhost\n      newAttributes.push('SameSite=Lax');\n      newAttributes.push('Path=/');\n\n      const newCookie = [nameValue, ...newAttributes].join('; ');\n      nextResponse.headers.append('Set-Cookie', newCookie);\n    });\n\n    return nextResponse;\n  } catch (error) {\n    console.error('[Proxy] Error:', error);\n    return NextResponse.json(\n      { error: 'Proxy error', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}