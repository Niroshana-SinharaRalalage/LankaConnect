{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/lib/react-query.ts"],"sourcesContent":["/**\r\n * React Query Configuration\r\n *\r\n * This file exports a factory function for creating QueryClient instances.\r\n * DO NOT add 'use client' directive - this is a utility module imported by both\r\n * Server and Client Components.\r\n *\r\n * CRITICAL NEXT.JS 16 + REACT 19 PATTERN:\r\n * - The QueryClient must be created using useState in the Providers component\r\n * - Module-level singletons break during SSR/hydration with React 19's automatic batching\r\n * - See: https://tanstack.com/query/latest/docs/framework/react/guides/nextjs\r\n */\r\n\r\nimport { QueryClient } from '@tanstack/react-query';\r\n\r\n/**\r\n * Creates a new QueryClient instance with recommended defaults for Next.js 16 + React 19\r\n *\r\n * Configuration:\r\n * - staleTime: 60s (avoid immediate refetch on client after SSR)\r\n * - refetchOnWindowFocus: true (keep data fresh when user returns)\r\n * - retry: 1 (single retry on failure)\r\n *\r\n * @returns A new QueryClient instance\r\n */\r\nexport function makeQueryClient() {\r\n  return new QueryClient({\r\n    defaultOptions: {\r\n      queries: {\r\n        // With SSR, we usually want to set some default staleTime\r\n        // above 0 to avoid refetching immediately on the client\r\n        staleTime: 60 * 1000,\r\n\r\n        // Refetch on window focus for data freshness\r\n        refetchOnWindowFocus: true,\r\n\r\n        // Only retry once on error (prevents infinite loops)\r\n        retry: 1,\r\n      },\r\n    },\r\n  });\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;CAWC;;;;AAED;;AAYO,SAAS;IACd,OAAO,IAAI,4LAAW,CAAC;QACrB,gBAAgB;YACd,SAAS;gBACP,0DAA0D;gBAC1D,wDAAwD;gBACxD,WAAW,KAAK;gBAEhB,6CAA6C;gBAC7C,sBAAsB;gBAEtB,qDAAqD;gBACrD,OAAO;YACT;QACF;IACF;AACF","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/api/client/api-errors.ts"],"sourcesContent":["/**\r\n * Base API Error class\r\n */\r\nexport class ApiError extends Error {\r\n  public readonly statusCode?: number;\r\n  public readonly validationErrors?: Record<string, string[]>;\r\n\r\n  constructor(message: string, statusCode?: number, validationErrors?: Record<string, string[]>) {\r\n    super(message);\r\n    this.name = 'ApiError';\r\n    this.statusCode = statusCode;\r\n    this.validationErrors = validationErrors;\r\n    Object.setPrototypeOf(this, ApiError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Network Error (no response from server)\r\n */\r\nexport class NetworkError extends ApiError {\r\n  constructor(message: string = 'Network error occurred') {\r\n    super(message);\r\n    this.name = 'NetworkError';\r\n    Object.setPrototypeOf(this, NetworkError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Validation Error (400)\r\n */\r\nexport class ValidationError extends ApiError {\r\n  constructor(message: string = 'Validation failed', validationErrors?: Record<string, string[]>) {\r\n    super(message, 400, validationErrors);\r\n    this.name = 'ValidationError';\r\n    Object.setPrototypeOf(this, ValidationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Unauthorized Error (401)\r\n */\r\nexport class UnauthorizedError extends ApiError {\r\n  constructor(message: string = 'Unauthorized') {\r\n    super(message, 401);\r\n    this.name = 'UnauthorizedError';\r\n    Object.setPrototypeOf(this, UnauthorizedError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Forbidden Error (403)\r\n */\r\nexport class ForbiddenError extends ApiError {\r\n  constructor(message: string = 'Forbidden') {\r\n    super(message, 403);\r\n    this.name = 'ForbiddenError';\r\n    Object.setPrototypeOf(this, ForbiddenError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Not Found Error (404)\r\n */\r\nexport class NotFoundError extends ApiError {\r\n  constructor(message: string = 'Resource not found') {\r\n    super(message, 404);\r\n    this.name = 'NotFoundError';\r\n    Object.setPrototypeOf(this, NotFoundError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Server Error (500+)\r\n */\r\nexport class ServerError extends ApiError {\r\n  constructor(message: string = 'Internal server error', statusCode: number = 500) {\r\n    super(message, statusCode);\r\n    this.name = 'ServerError';\r\n    Object.setPrototypeOf(this, ServerError.prototype);\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;;;;;AACM,MAAM,iBAAiB;IACZ,WAAoB;IACpB,iBAA4C;IAE5D,YAAY,OAAe,EAAE,UAAmB,EAAE,gBAA2C,CAAE;QAC7F,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,gBAAgB,GAAG;QACxB,OAAO,cAAc,CAAC,IAAI,EAAE,SAAS,SAAS;IAChD;AACF;AAKO,MAAM,qBAAqB;IAChC,YAAY,UAAkB,wBAAwB,CAAE;QACtD,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,aAAa,SAAS;IACpD;AACF;AAKO,MAAM,wBAAwB;IACnC,YAAY,UAAkB,mBAAmB,EAAE,gBAA2C,CAAE;QAC9F,KAAK,CAAC,SAAS,KAAK;QACpB,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,gBAAgB,SAAS;IACvD;AACF;AAKO,MAAM,0BAA0B;IACrC,YAAY,UAAkB,cAAc,CAAE;QAC5C,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,kBAAkB,SAAS;IACzD;AACF;AAKO,MAAM,uBAAuB;IAClC,YAAY,UAAkB,WAAW,CAAE;QACzC,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,eAAe,SAAS;IACtD;AACF;AAKO,MAAM,sBAAsB;IACjC,YAAY,UAAkB,oBAAoB,CAAE;QAClD,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,cAAc,SAAS;IACrD;AACF;AAKO,MAAM,oBAAoB;IAC/B,YAAY,UAAkB,uBAAuB,EAAE,aAAqB,GAAG,CAAE;QAC/E,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG;QACZ,OAAO,cAAc,CAAC,IAAI,EAAE,YAAY,SAAS;IACnD;AACF","debugId":null}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/storage/localStorage.ts"],"sourcesContent":["/**\r\n * LocalStorage Utility\r\n * Type-safe wrapper for localStorage with error handling\r\n */\r\n\r\nconst STORAGE_KEYS = {\r\n  ACCESS_TOKEN: 'lankaconnect_access_token',\r\n  REFRESH_TOKEN: 'lankaconnect_refresh_token',\r\n  USER: 'lankaconnect_user',\r\n} as const;\r\n\r\nexport class LocalStorageService {\r\n  /**\r\n   * Check if localStorage is available\r\n   */\r\n  private static isAvailable(): boolean {\r\n    try {\r\n      const test = '__localStorage_test__';\r\n      localStorage.setItem(test, test);\r\n      localStorage.removeItem(test);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get item from localStorage\r\n   */\r\n  static getItem<T>(key: string): T | null {\r\n    if (!this.isAvailable()) {\r\n      console.warn('localStorage is not available');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const item = localStorage.getItem(key);\r\n      if (!item) return null;\r\n      return JSON.parse(item) as T;\r\n    } catch (error) {\r\n      console.error(`Error reading from localStorage (${key}):`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set item in localStorage\r\n   */\r\n  static setItem<T>(key: string, value: T): boolean {\r\n    if (!this.isAvailable()) {\r\n      console.warn('localStorage is not available');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      localStorage.setItem(key, JSON.stringify(value));\r\n      return true;\r\n    } catch (error) {\r\n      console.error(`Error writing to localStorage (${key}):`, error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove item from localStorage\r\n   */\r\n  static removeItem(key: string): void {\r\n    if (!this.isAvailable()) {\r\n      console.warn('localStorage is not available');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      localStorage.removeItem(key);\r\n    } catch (error) {\r\n      console.error(`Error removing from localStorage (${key}):`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all items from localStorage\r\n   */\r\n  static clear(): void {\r\n    if (!this.isAvailable()) {\r\n      console.warn('localStorage is not available');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      localStorage.clear();\r\n    } catch (error) {\r\n      console.error('Error clearing localStorage:', error);\r\n    }\r\n  }\r\n\r\n  // Auth-specific methods\r\n  static getAccessToken(): string | null {\r\n    return this.getItem<string>(STORAGE_KEYS.ACCESS_TOKEN);\r\n  }\r\n\r\n  static setAccessToken(token: string): boolean {\r\n    return this.setItem(STORAGE_KEYS.ACCESS_TOKEN, token);\r\n  }\r\n\r\n  static getRefreshToken(): string | null {\r\n    return this.getItem<string>(STORAGE_KEYS.REFRESH_TOKEN);\r\n  }\r\n\r\n  static setRefreshToken(token: string): boolean {\r\n    return this.setItem(STORAGE_KEYS.REFRESH_TOKEN, token);\r\n  }\r\n\r\n  static getUser<T>(): T | null {\r\n    return this.getItem<T>(STORAGE_KEYS.USER);\r\n  }\r\n\r\n  static setUser<T>(user: T): boolean {\r\n    return this.setItem(STORAGE_KEYS.USER, user);\r\n  }\r\n\r\n  static clearAuth(): void {\r\n    this.removeItem(STORAGE_KEYS.ACCESS_TOKEN);\r\n    this.removeItem(STORAGE_KEYS.REFRESH_TOKEN);\r\n    this.removeItem(STORAGE_KEYS.USER);\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAED,MAAM,eAAe;IACnB,cAAc;IACd,eAAe;IACf,MAAM;AACR;AAEO,MAAM;IACX;;GAEC,GACD,OAAe,cAAuB;QACpC,IAAI;YACF,MAAM,OAAO;YACb,aAAa,OAAO,CAAC,MAAM;YAC3B,aAAa,UAAU,CAAC;YACxB,OAAO;QACT,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEA;;GAEC,GACD,OAAO,QAAW,GAAW,EAAY;QACvC,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI;YACvB,QAAQ,IAAI,CAAC;YACb,OAAO;QACT;QAEA,IAAI;YACF,MAAM,OAAO,aAAa,OAAO,CAAC;YAClC,IAAI,CAAC,MAAM,OAAO;YAClB,OAAO,KAAK,KAAK,CAAC;QACpB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,iCAAiC,EAAE,IAAI,EAAE,CAAC,EAAE;YAC3D,OAAO;QACT;IACF;IAEA;;GAEC,GACD,OAAO,QAAW,GAAW,EAAE,KAAQ,EAAW;QAChD,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI;YACvB,QAAQ,IAAI,CAAC;YACb,OAAO;QACT;QAEA,IAAI;YACF,aAAa,OAAO,CAAC,KAAK,KAAK,SAAS,CAAC;YACzC,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,+BAA+B,EAAE,IAAI,EAAE,CAAC,EAAE;YACzD,OAAO;QACT;IACF;IAEA;;GAEC,GACD,OAAO,WAAW,GAAW,EAAQ;QACnC,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI;YACvB,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,IAAI;YACF,aAAa,UAAU,CAAC;QAC1B,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,CAAC,kCAAkC,EAAE,IAAI,EAAE,CAAC,EAAE;QAC9D;IACF;IAEA;;GAEC,GACD,OAAO,QAAc;QACnB,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI;YACvB,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,IAAI;YACF,aAAa,KAAK;QACpB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;QAChD;IACF;IAEA,wBAAwB;IACxB,OAAO,iBAAgC;QACrC,OAAO,IAAI,CAAC,OAAO,CAAS,aAAa,YAAY;IACvD;IAEA,OAAO,eAAe,KAAa,EAAW;QAC5C,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,YAAY,EAAE;IACjD;IAEA,OAAO,kBAAiC;QACtC,OAAO,IAAI,CAAC,OAAO,CAAS,aAAa,aAAa;IACxD;IAEA,OAAO,gBAAgB,KAAa,EAAW;QAC7C,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,aAAa,EAAE;IAClD;IAEA,OAAO,UAAuB;QAC5B,OAAO,IAAI,CAAC,OAAO,CAAI,aAAa,IAAI;IAC1C;IAEA,OAAO,QAAW,IAAO,EAAW;QAClC,OAAO,IAAI,CAAC,OAAO,CAAC,aAAa,IAAI,EAAE;IACzC;IAEA,OAAO,YAAkB;QACvB,IAAI,CAAC,UAAU,CAAC,aAAa,YAAY;QACzC,IAAI,CAAC,UAAU,CAAC,aAAa,aAAa;QAC1C,IAAI,CAAC,UAAU,CAAC,aAAa,IAAI;IACnC;AACF","debugId":null}},
    {"offset": {"line": 334, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/presentation/store/useAuthStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { devtools, persist } from 'zustand/middleware';\r\nimport type { UserDto, AuthTokens } from '@/infrastructure/api/types/auth.types';\r\nimport { LocalStorageService } from '@/infrastructure/storage/localStorage';\r\nimport { apiClient } from '@/infrastructure/api/client/api-client';\r\n\r\ninterface AuthState {\r\n  // State\r\n  user: UserDto | null;\r\n  accessToken: string | null;\r\n  refreshToken: string | null;\r\n  isAuthenticated: boolean;\r\n  isLoading: boolean;\r\n\r\n  // Actions\r\n  setAuth: (user: UserDto, tokens: AuthTokens) => void;\r\n  clearAuth: () => void;\r\n  setLoading: (loading: boolean) => void;\r\n  updateUser: (user: Partial<UserDto>) => void;\r\n}\r\n\r\n/**\r\n * Auth Store\r\n * Global state management for authentication using Zustand\r\n */\r\nexport const useAuthStore = create<AuthState>()(\r\n  devtools(\r\n    persist(\r\n      (set, get) => ({\r\n        // Initial state\r\n        user: null,\r\n        accessToken: null,\r\n        refreshToken: null,\r\n        isAuthenticated: false,\r\n        isLoading: false,\r\n\r\n        // Set authentication (after login/register)\r\n        setAuth: (user, tokens) => {\r\n          // Store tokens in localStorage\r\n          LocalStorageService.setAccessToken(tokens.accessToken);\r\n          LocalStorageService.setRefreshToken(tokens.refreshToken);\r\n          LocalStorageService.setUser(user);\r\n\r\n          // Set auth token in API client\r\n          apiClient.setAuthToken(tokens.accessToken);\r\n\r\n          set({\r\n            user,\r\n            accessToken: tokens.accessToken,\r\n            refreshToken: tokens.refreshToken,\r\n            isAuthenticated: true,\r\n            isLoading: false,\r\n          });\r\n        },\r\n\r\n        // Clear authentication (logout)\r\n        clearAuth: () => {\r\n          // Clear localStorage\r\n          LocalStorageService.clearAuth();\r\n\r\n          // Clear auth token from API client\r\n          apiClient.clearAuthToken();\r\n\r\n          set({\r\n            user: null,\r\n            accessToken: null,\r\n            refreshToken: null,\r\n            isAuthenticated: false,\r\n            isLoading: false,\r\n          });\r\n        },\r\n\r\n        // Set loading state\r\n        setLoading: (loading) => {\r\n          set({ isLoading: loading });\r\n        },\r\n\r\n        // Update user data\r\n        updateUser: (userData) => {\r\n          const currentUser = get().user;\r\n          if (!currentUser) return;\r\n\r\n          const updatedUser = { ...currentUser, ...userData };\r\n          LocalStorageService.setUser(updatedUser);\r\n\r\n          set({ user: updatedUser });\r\n        },\r\n      }),\r\n      {\r\n        name: 'auth-storage',\r\n        partialize: (state) => ({\r\n          user: state.user,\r\n          accessToken: state.accessToken,\r\n          refreshToken: state.refreshToken,\r\n          isAuthenticated: state.isAuthenticated,\r\n        }),\r\n        onRehydrateStorage: () => (state) => {\r\n          // Restore auth token to API client on app load\r\n          if (state?.accessToken) {\r\n            apiClient.setAuthToken(state.accessToken);\r\n          }\r\n        },\r\n      }\r\n    ),\r\n    { name: 'AuthStore' }\r\n  )\r\n);\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AAEA;AACA;;;;;AAqBO,MAAM,eAAe,IAAA,kJAAM,IAChC,IAAA,yJAAQ,EACN,IAAA,wJAAO,EACL,CAAC,KAAK,MAAQ,CAAC;QACb,gBAAgB;QAChB,MAAM;QACN,aAAa;QACb,cAAc;QACd,iBAAiB;QACjB,WAAW;QAEX,4CAA4C;QAC5C,SAAS,CAAC,MAAM;YACd,+BAA+B;YAC/B,uKAAmB,CAAC,cAAc,CAAC,OAAO,WAAW;YACrD,uKAAmB,CAAC,eAAe,CAAC,OAAO,YAAY;YACvD,uKAAmB,CAAC,OAAO,CAAC;YAE5B,+BAA+B;YAC/B,oKAAS,CAAC,YAAY,CAAC,OAAO,WAAW;YAEzC,IAAI;gBACF;gBACA,aAAa,OAAO,WAAW;gBAC/B,cAAc,OAAO,YAAY;gBACjC,iBAAiB;gBACjB,WAAW;YACb;QACF;QAEA,gCAAgC;QAChC,WAAW;YACT,qBAAqB;YACrB,uKAAmB,CAAC,SAAS;YAE7B,mCAAmC;YACnC,oKAAS,CAAC,cAAc;YAExB,IAAI;gBACF,MAAM;gBACN,aAAa;gBACb,cAAc;gBACd,iBAAiB;gBACjB,WAAW;YACb;QACF;QAEA,oBAAoB;QACpB,YAAY,CAAC;YACX,IAAI;gBAAE,WAAW;YAAQ;QAC3B;QAEA,mBAAmB;QACnB,YAAY,CAAC;YACX,MAAM,cAAc,MAAM,IAAI;YAC9B,IAAI,CAAC,aAAa;YAElB,MAAM,cAAc;gBAAE,GAAG,WAAW;gBAAE,GAAG,QAAQ;YAAC;YAClD,uKAAmB,CAAC,OAAO,CAAC;YAE5B,IAAI;gBAAE,MAAM;YAAY;QAC1B;IACF,CAAC,GACD;IACE,MAAM;IACN,YAAY,CAAC,QAAU,CAAC;YACtB,MAAM,MAAM,IAAI;YAChB,aAAa,MAAM,WAAW;YAC9B,cAAc,MAAM,YAAY;YAChC,iBAAiB,MAAM,eAAe;QACxC,CAAC;IACD,oBAAoB,IAAM,CAAC;YACzB,+CAA+C;YAC/C,IAAI,OAAO,aAAa;gBACtB,oKAAS,CAAC,YAAY,CAAC,MAAM,WAAW;YAC1C;QACF;AACF,IAEF;IAAE,MAAM;AAAY","debugId":null}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/api/services/tokenRefreshService.ts"],"sourcesContent":["/**\n * Token Refresh Service\n * Handles automatic token refresh with retry queue to prevent duplicate refreshes\n *\n * Features:\n * - Automatic retry on 401 Unauthorized\n * - Prevents duplicate refresh requests using a queue\n * - Thread-safe refresh operation\n * - Transparent token refresh without user interaction\n */\n\nimport { apiClient } from '../client/api-client';\nimport { useAuthStore } from '@/presentation/store/useAuthStore';\n\nclass TokenRefreshService {\n  private isRefreshing = false;\n  private refreshSubscribers: Array<(token: string) => void> = [];\n\n  /**\n   * Check if token refresh is currently in progress\n   */\n  public get isRefreshInProgress(): boolean {\n    return this.isRefreshing;\n  }\n\n  /**\n   * Add subscriber to be notified when token refresh completes\n   */\n  private subscribeTokenRefresh(callback: (token: string) => void): void {\n    this.refreshSubscribers.push(callback);\n  }\n\n  /**\n   * Notify all subscribers that token refresh is complete\n   */\n  private onTokenRefreshed(token: string): void {\n    this.refreshSubscribers.forEach((callback) => callback(token));\n    this.refreshSubscribers = [];\n  }\n\n  /**\n   * Attempt to refresh the access token\n   * Returns new access token if successful, null otherwise\n   */\n  public async refreshAccessToken(): Promise<string | null> {\n    // If refresh is already in progress, queue this request\n    if (this.isRefreshing) {\n      return new Promise<string | null>((resolve) => {\n        this.subscribeTokenRefresh((token: string) => {\n          resolve(token);\n        });\n      });\n    }\n\n    const { refreshToken, clearAuth } = useAuthStore.getState();\n\n    // No refresh token available\n    if (!refreshToken) {\n      console.error('üîí No refresh token available - redirecting to login');\n      clearAuth();\n      return null;\n    }\n\n    this.isRefreshing = true;\n\n    try {\n      console.log('üîÑ Attempting to refresh access token...');\n\n      // Call the refresh endpoint\n      const response = await apiClient.post<{\n        accessToken: string;\n        tokenExpiresAt: string;\n      }>('/Auth/refresh', {});\n\n      const { accessToken, tokenExpiresAt } = response;\n\n      console.log('‚úÖ Token refreshed successfully', {\n        expiresAt: tokenExpiresAt,\n      });\n\n      // Update auth store with new token\n      const { setAuth, user } = useAuthStore.getState();\n      if (user) {\n        setAuth(user, {\n          accessToken,\n          refreshToken, // Keep existing refresh token (backend rotates it via cookie)\n        });\n      }\n\n      // Notify all queued requests\n      this.onTokenRefreshed(accessToken);\n\n      this.isRefreshing = false;\n      return accessToken;\n    } catch (error) {\n      console.error('‚ùå Token refresh failed:', error);\n\n      // Clear auth and notify subscribers\n      this.isRefreshing = false;\n      this.onTokenRefreshed('');\n\n      // Clear auth state - user needs to login again\n      const { clearAuth } = useAuthStore.getState();\n      clearAuth();\n\n      return null;\n    }\n  }\n\n  /**\n   * Retry a failed request after refreshing the token\n   */\n  public async retryRequestAfterRefresh<T>(\n    originalRequest: () => Promise<T>\n  ): Promise<T | null> {\n    const newToken = await this.refreshAccessToken();\n\n    if (!newToken) {\n      throw new Error('Token refresh failed - please login again');\n    }\n\n    // Retry the original request with the new token\n    try {\n      return await originalRequest();\n    } catch (error) {\n      console.error('‚ùå Retry request failed even after token refresh:', error);\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const tokenRefreshService = new TokenRefreshService();\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;AAED;AACA;;;AAEA,MAAM;IACI,eAAe,MAAM;IACrB,qBAAqD,EAAE,CAAC;IAEhE;;GAEC,GACD,IAAW,sBAA+B;QACxC,OAAO,IAAI,CAAC,YAAY;IAC1B;IAEA;;GAEC,GACD,AAAQ,sBAAsB,QAAiC,EAAQ;QACrE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;IAC/B;IAEA;;GAEC,GACD,AAAQ,iBAAiB,KAAa,EAAQ;QAC5C,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,WAAa,SAAS;QACvD,IAAI,CAAC,kBAAkB,GAAG,EAAE;IAC9B;IAEA;;;GAGC,GACD,MAAa,qBAA6C;QACxD,wDAAwD;QACxD,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,OAAO,IAAI,QAAuB,CAAC;gBACjC,IAAI,CAAC,qBAAqB,CAAC,CAAC;oBAC1B,QAAQ;gBACV;YACF;QACF;QAEA,MAAM,EAAE,YAAY,EAAE,SAAS,EAAE,GAAG,4JAAY,CAAC,QAAQ;QAEzD,6BAA6B;QAC7B,IAAI,CAAC,cAAc;YACjB,QAAQ,KAAK,CAAC;YACd;YACA,OAAO;QACT;QAEA,IAAI,CAAC,YAAY,GAAG;QAEpB,IAAI;YACF,QAAQ,GAAG,CAAC;YAEZ,4BAA4B;YAC5B,MAAM,WAAW,MAAM,oKAAS,CAAC,IAAI,CAGlC,iBAAiB,CAAC;YAErB,MAAM,EAAE,WAAW,EAAE,cAAc,EAAE,GAAG;YAExC,QAAQ,GAAG,CAAC,kCAAkC;gBAC5C,WAAW;YACb;YAEA,mCAAmC;YACnC,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,4JAAY,CAAC,QAAQ;YAC/C,IAAI,MAAM;gBACR,QAAQ,MAAM;oBACZ;oBACA;gBACF;YACF;YAEA,6BAA6B;YAC7B,IAAI,CAAC,gBAAgB,CAAC;YAEtB,IAAI,CAAC,YAAY,GAAG;YACpB,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,2BAA2B;YAEzC,oCAAoC;YACpC,IAAI,CAAC,YAAY,GAAG;YACpB,IAAI,CAAC,gBAAgB,CAAC;YAEtB,+CAA+C;YAC/C,MAAM,EAAE,SAAS,EAAE,GAAG,4JAAY,CAAC,QAAQ;YAC3C;YAEA,OAAO;QACT;IACF;IAEA;;GAEC,GACD,MAAa,yBACX,eAAiC,EACd;QACnB,MAAM,WAAW,MAAM,IAAI,CAAC,kBAAkB;QAE9C,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM;QAClB;QAEA,gDAAgD;QAChD,IAAI;YACF,OAAO,MAAM;QACf,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,oDAAoD;YAClE,MAAM;QACR;IACF;AACF;AAGO,MAAM,sBAAsB,IAAI","debugId":null}},
    {"offset": {"line": 531, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/infrastructure/api/client/api-client.ts"],"sourcesContent":["import axios, { AxiosInstance, AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';\r\nimport {\r\n  ApiError,\r\n  NetworkError,\r\n  ValidationError,\r\n  UnauthorizedError,\r\n  ForbiddenError,\r\n  NotFoundError,\r\n  ServerError,\r\n} from './api-errors';\r\nimport { tokenRefreshService } from '../services/tokenRefreshService';\r\n\r\n/**\r\n * API Client Configuration\r\n */\r\nexport interface ApiClientConfig {\r\n  baseURL: string;\r\n  timeout?: number;\r\n  headers?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Callback for handling 401 Unauthorized errors (token expiration)\r\n */\r\ntype UnauthorizedCallback = () => void;\r\n\r\n/**\r\n * API Client\r\n * Singleton pattern for managing HTTP requests\r\n */\r\nexport class ApiClient {\r\n  private static instance: ApiClient;\r\n  private axiosInstance: AxiosInstance;\r\n  private authToken: string | null = null;\r\n  private onUnauthorized: UnauthorizedCallback | null = null;\r\n\r\n  private constructor(config?: Partial<ApiClientConfig>) {\r\n    const baseURL = config?.baseURL || process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000/api';\r\n\r\n    this.axiosInstance = axios.create({\r\n      baseURL,\r\n      timeout: config?.timeout || 30000,\r\n      withCredentials: true, // Enable credentials for CORS requests\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        ...config?.headers,\r\n      },\r\n    });\r\n\r\n    this.setupInterceptors();\r\n  }\r\n\r\n  /**\r\n   * Get singleton instance\r\n   */\r\n  public static getInstance(config?: Partial<ApiClientConfig>): ApiClient {\r\n    if (!ApiClient.instance) {\r\n      ApiClient.instance = new ApiClient(config);\r\n    }\r\n    return ApiClient.instance;\r\n  }\r\n\r\n  /**\r\n   * Setup request and response interceptors\r\n   */\r\n  private setupInterceptors(): void {\r\n    // Request interceptor\r\n    this.axiosInstance.interceptors.request.use(\r\n      (config) => {\r\n        // Add auth token if available\r\n        if (this.authToken) {\r\n          config.headers.Authorization = `Bearer ${this.authToken}`;\r\n        }\r\n\r\n        // PHASE 6A.10: Comprehensive request logging for debugging\r\n        const authHeader = config.headers.Authorization;\r\n        const authValue = typeof authHeader === 'string' && authHeader.startsWith('Bearer ')\r\n          ? `Bearer ${authHeader.substring(7, 30)}...`\r\n          : 'Not set';\r\n\r\n        console.log('üöÄ API Request:', {\r\n          method: config.method?.toUpperCase(),\r\n          url: config.url,\r\n          baseURL: config.baseURL,\r\n          fullURL: `${config.baseURL}${config.url}`,\r\n          headers: {\r\n            'Content-Type': config.headers['Content-Type'],\r\n            'Authorization': authValue,\r\n            'Origin': config.headers.Origin || (typeof window !== 'undefined' ? window.location.origin : 'SSR'),\r\n          },\r\n          data: config.data ? JSON.stringify(config.data).substring(0, 200) : 'No data',\r\n        });\r\n\r\n        return config;\r\n      },\r\n      (error) => {\r\n        console.error('‚ùå Request Interceptor Error:', error);\r\n        return Promise.reject(this.handleError(error));\r\n      }\r\n    );\r\n\r\n    // Response interceptor\r\n    this.axiosInstance.interceptors.response.use(\r\n      (response) => {\r\n        // PHASE 6A.10: Log successful responses\r\n        console.log('‚úÖ API Response Success:', {\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          url: response.config.url,\r\n          headers: {\r\n            'Access-Control-Allow-Origin': response.headers['access-control-allow-origin'],\r\n            'Access-Control-Allow-Credentials': response.headers['access-control-allow-credentials'],\r\n            'Content-Type': response.headers['content-type'],\r\n          },\r\n          dataSize: JSON.stringify(response.data || {}).length,\r\n        });\r\n        return response;\r\n      },\r\n      async (error) => {\r\n        const originalRequest = error.config;\r\n\r\n        // Check if this is a 401 error and we haven't already retried\r\n        if (error.response?.status === 401 && !originalRequest._retry) {\r\n          // Skip refresh for auth endpoints (login, register, refresh)\r\n          const isAuthEndpoint = originalRequest.url?.includes('/Auth/login') ||\r\n                                  originalRequest.url?.includes('/Auth/register') ||\r\n                                  originalRequest.url?.includes('/Auth/refresh');\r\n\r\n          if (!isAuthEndpoint) {\r\n            console.log('üîì 401 Unauthorized - attempting token refresh...');\r\n\r\n            // Mark that we've tried to refresh for this request\r\n            originalRequest._retry = true;\r\n\r\n            try {\r\n              // Attempt to refresh the token\r\n              const newToken = await tokenRefreshService.refreshAccessToken();\r\n\r\n              if (newToken) {\r\n                // Update the Authorization header with the new token\r\n                originalRequest.headers['Authorization'] = `Bearer ${newToken}`;\r\n\r\n                console.log('üîÑ Retrying request with new token...');\r\n\r\n                // Retry the original request\r\n                return this.axiosInstance(originalRequest);\r\n              }\r\n            } catch (refreshError) {\r\n              console.error('‚ùå Token refresh failed, redirecting to login');\r\n              // Token refresh failed - user will be redirected to login by tokenRefreshService\r\n              return Promise.reject(refreshError);\r\n            }\r\n          }\r\n        }\r\n\r\n        // PHASE 6A.10: Comprehensive error logging\r\n        console.error('‚ùå API Response Error:', {\r\n          message: error.message,\r\n          name: error.name,\r\n          code: error.code,\r\n          request: error.request ? {\r\n            method: error.config?.method,\r\n            url: error.config?.url,\r\n            headers: error.config?.headers,\r\n          } : 'No request object',\r\n          response: error.response ? {\r\n            status: error.response.status,\r\n            statusText: error.response.statusText,\r\n            headers: error.response.headers,\r\n            data: error.response.data,\r\n          } : 'No response object',\r\n          isAxiosError: axios.isAxiosError(error),\r\n        });\r\n        return Promise.reject(this.handleError(error));\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle errors and convert to custom error types\r\n   */\r\n  private handleError(error: unknown): ApiError {\r\n    if (axios.isAxiosError(error)) {\r\n      const axiosError = error as AxiosError<any>;\r\n\r\n      // Network error (no response)\r\n      if (!axiosError.response) {\r\n        return new NetworkError(axiosError.message || 'Network error occurred');\r\n      }\r\n\r\n      const { status, data } = axiosError.response;\r\n\r\n      // Extract error message\r\n      const message = data?.message || data?.error || axiosError.message || 'An error occurred';\r\n\r\n      // Handle specific status codes\r\n      switch (status) {\r\n        case 400:\r\n          return new ValidationError(message, data?.errors || data?.validationErrors);\r\n        case 401:\r\n          // Token expired or invalid - trigger logout callback\r\n          if (this.onUnauthorized) {\r\n            this.onUnauthorized();\r\n          }\r\n          return new UnauthorizedError(message);\r\n        case 403:\r\n          return new ForbiddenError(message);\r\n        case 404:\r\n          return new NotFoundError(message);\r\n        case 500:\r\n        case 502:\r\n        case 503:\r\n        case 504:\r\n          return new ServerError(message, status);\r\n        default:\r\n          return new ApiError(message, status);\r\n      }\r\n    }\r\n\r\n    // Unknown error\r\n    if (error instanceof Error) {\r\n      return new ApiError(error.message);\r\n    }\r\n\r\n    return new ApiError('An unknown error occurred');\r\n  }\r\n\r\n  /**\r\n   * Set callback for handling 401 Unauthorized errors\r\n   */\r\n  public setUnauthorizedCallback(callback: UnauthorizedCallback): void {\r\n    this.onUnauthorized = callback;\r\n  }\r\n\r\n  /**\r\n   * Set authentication token\r\n   */\r\n  public setAuthToken(token: string): void {\r\n    this.authToken = token;\r\n  }\r\n\r\n  /**\r\n   * Clear authentication token\r\n   */\r\n  public clearAuthToken(): void {\r\n    this.authToken = null;\r\n  }\r\n\r\n  /**\r\n   * GET request\r\n   */\r\n  public async get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.get(url, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * POST request\r\n   */\r\n  public async post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.post(url, data, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * PUT request\r\n   */\r\n  public async put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.put(url, data, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * PATCH request\r\n   */\r\n  public async patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.patch(url, data, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * DELETE request\r\n   */\r\n  public async delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\r\n    const response: AxiosResponse<T> = await this.axiosInstance.delete(url, config);\r\n    return response.data;\r\n  }\r\n\r\n  /**\r\n   * POST request with multipart/form-data (for file uploads)\r\n   * Note: Use transformRequest to prevent axios from setting Content-Type, letting browser add boundary\r\n   */\r\n  public async postMultipart<T = any>(\r\n    url: string,\r\n    formData: FormData,\r\n    config?: AxiosRequestConfig\r\n  ): Promise<T> {\r\n    // Use transformRequest to bypass axios default header handling\r\n    // This lets the browser set the correct multipart/form-data header with boundary\r\n    const response: AxiosResponse<T> = await this.axiosInstance.post(url, formData, {\r\n      ...config,\r\n      transformRequest: [(data) => data], // Return data as-is, don't transform\r\n      headers: {\r\n        ...config?.headers,\r\n      },\r\n    });\r\n    return response.data;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const apiClient = ApiClient.getInstance();\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 770, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/presentation/providers/AuthProvider.tsx"],"sourcesContent":["'use client';\n\nimport { useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { apiClient } from '@/infrastructure/api/client/api-client';\nimport { useAuthStore } from '@/presentation/store/useAuthStore';\n\n/**\n * AuthProvider Component\n * Sets up global 401 error handling for automatic logout on token expiration\n *\n * This component:\n * 1. Registers a callback with the API client to handle 401 Unauthorized errors\n * 2. When a 401 occurs (token expired), it:\n *    - Clears authentication state\n *    - Redirects to login page\n * 3. Prevents multiple redirects with a flag\n */\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const router = useRouter();\n  const clearAuth = useAuthStore((state) => state.clearAuth);\n\n  useEffect(() => {\n    let isHandling401 = false;\n\n    // Set up 401 error handler\n    apiClient.setUnauthorizedCallback(() => {\n      // Prevent multiple simultaneous logout/redirect calls\n      if (isHandling401) return;\n      isHandling401 = true;\n\n      // Clear authentication state\n      clearAuth();\n\n      // Redirect to login page\n      router.push('/login');\n\n      // Reset flag after redirect\n      setTimeout(() => {\n        isHandling401 = false;\n      }, 1000);\n    });\n  }, [router, clearAuth]);\n\n  return <>{children}</>;\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAkBO,SAAS,aAAa,EAAE,QAAQ,EAAiC;IACtE,MAAM,SAAS,IAAA,+IAAS;IACxB,MAAM,YAAY,IAAA,4JAAY,EAAC,CAAC,QAAU,MAAM,SAAS;IAEzD,IAAA,kNAAS,EAAC;QACR,IAAI,gBAAgB;QAEpB,2BAA2B;QAC3B,oKAAS,CAAC,uBAAuB,CAAC;YAChC,sDAAsD;YACtD,IAAI,eAAe;YACnB,gBAAgB;YAEhB,6BAA6B;YAC7B;YAEA,yBAAyB;YACzB,OAAO,IAAI,CAAC;YAEZ,4BAA4B;YAC5B,WAAW;gBACT,gBAAgB;YAClB,GAAG;QACL;IACF,GAAG;QAAC;QAAQ;KAAU;IAEtB,qBAAO;kBAAG;;AACZ","debugId":null}},
    {"offset": {"line": 816, "column": 0}, "map": {"version":3,"sources":["file:///C:/Work/LankaConnect/web/src/app/providers.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { useState } from 'react';\r\nimport { QueryClientProvider } from '@tanstack/react-query';\r\nimport { makeQueryClient } from '@/lib/react-query';\r\nimport { AuthProvider } from '@/presentation/providers/AuthProvider';\r\n\r\n/**\r\n * Providers Component\r\n *\r\n * CRITICAL PATTERN for Next.js 16 + React 19 + React Query v5:\r\n *\r\n * We MUST use useState with an initialization function to create the QueryClient.\r\n * This ensures the client is created ONCE on component mount and survives React 19's\r\n * automatic batching during hydration.\r\n *\r\n * DO NOT use module-level singletons or external functions - this breaks during\r\n * SSR/hydration and causes queries to never execute.\r\n *\r\n * See: https://tanstack.com/query/latest/docs/framework/react/guides/nextjs\r\n *\r\n * AuthProvider: Sets up global 401 error handling for automatic logout on token expiration\r\n */\r\nexport function Providers({ children }: { children: React.ReactNode }) {\r\n  // ‚úÖ CORRECT: Use useState with initialization function\r\n  // This creates the QueryClient ONCE on client mount\r\n  // and ensures it survives React 19's automatic batching during hydration\r\n  const [queryClient] = useState(() => makeQueryClient());\r\n\r\n  return (\r\n    <QueryClientProvider client={queryClient}>\r\n      <AuthProvider>\r\n        {children}\r\n      </AuthProvider>\r\n    </QueryClientProvider>\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAuBO,SAAS,UAAU,EAAE,QAAQ,EAAiC;IACnE,uDAAuD;IACvD,oDAAoD;IACpD,yEAAyE;IACzE,MAAM,CAAC,YAAY,GAAG,IAAA,iNAAQ,EAAC,IAAM,IAAA,+IAAe;IAEpD,qBACE,8OAAC,6MAAmB;QAAC,QAAQ;kBAC3B,cAAA,8OAAC,iKAAY;sBACV;;;;;;;;;;;AAIT","debugId":null}}]
}